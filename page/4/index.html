<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/remixicon.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?e6048c3e856b5cbdb1e6ef6e00d5b63d";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <div class="bg-box-wrapper">
        <img src="/images/cover-blur.jpg" data-uhd-src="/images/cover-uhd.jpg" alt="image frame" class="cover-progressive-img" id="cover-img"/>
      </div>
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">四月八日</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['最轻的并不是一根羽毛，而是一双飞鸟的翅膀', '愿你足够强大，也要足够温柔', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <article class="articles">
    
    
    
    
    <article
  id="post-javascript/fp/(5)针对复杂应用的设计模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/9e8f6e6a/"
    >5.针对复杂应用的设计模式</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/9e8f6e6a/" class="article-date">
  <time datetime="2020-11-08T06:57:07.000Z" itemprop="datePublished">2020-11-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>命令式处理异常方式的问题<br>使用容器，以防访问无效数据<br>用Functor的实现来做数据转换<br>利于组合的Monad数据类型<br>使用Monadic类型来巩固错误处理策略<br>Monadic类型的组合与交错</p>
<h4 id="命令式错误处理的不足"><a href="#命令式错误处理的不足" class="headerlink" title="命令式错误处理的不足"></a>命令式错误处理的不足</h4><p>函数式编程其实可以把错误处理得比任何其他开发风格更为优雅，软件中的许多问题都是由于数据不经意地变成了<code>null</code>或<code>undefined</code>、出现了异常、失去网络连接等情况造成的。所以需要大量得错误捕获代码，在每一个使用引用得地方判断<code>null</code>或<code>undefined</code>,是的代码得逻辑越来月复杂</p>
<h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h5><p>我们尝试使用try,catch来捕获错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> student = findStudent(<span class="string">&#x27;444-44-4444&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ERROR&#x27;</span> + e.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样会与函数式的设计有兼容性问题。</p>
<ul>
<li>难以与其他函数组合或链接。</li>
<li>违反了引用透明性，因为抛出异常会导致函数调用出现另一出口，所以不能确保单一的可预测的返回值。</li>
<li>会引起副作用，因为异常会在函数调用之外对堆栈引发不可预料的影响。</li>
<li>违反非局域性的原则，因为用于恢复异常的代码与原始的函数调用渐行渐远。当发生错误时，函数离开局部栈与环境。即 <code>try</code> 中的逻辑会在遇到错误时停止执行，转移到<code>catch</code>处理错误逻辑</li>
<li>不能只关注函数的返回值，调用者需要负责声明catch块中的异常匹配类型来管理特定的异常。</li>
<li>当有多个异常条件时会出现嵌套的异常处理块</li>
</ul>
<p>其中一个常见的场景是JavaScript中因在null对象上调用函数所产生的TypeError。</p>
<h5 id="空值（null）检查问题"><a href="#空值（null）检查问题" class="headerlink" title="空值（null）检查问题"></a>空值（null）检查问题</h5><p>本来可以简单地创建一个lens来获取该属性，若是<code>null</code>即返回<code>undefined</code>，但它并不会打印任何错误信息。</p>
<p>这使代码需要大量的判空检查代码。不管是使用<code>try-catch</code>还是<code>null</code>检查，都是被动的解决方式。</p>
<h5 id="Functor-一种更好得解决方案"><a href="#Functor-一种更好得解决方案" class="headerlink" title="Functor 一种更好得解决方案"></a>Functor 一种更好得解决方案</h5><p>思想说起来也非常简单，创建一个安全的容器，来存放危险代码</p>
<h5 id="包裹不安全的值"><a href="#包裹不安全的值" class="headerlink" title="包裹不安全的值"></a>包裹不安全的值</h5><p>map可以是一个更广义的map的概念，而不仅仅是数组。在函数式JavaScript中，map只不过是一个函数，由于引用透明性，只要输入相同，map永远会返回相同的结果。当然，还可以认为map是可以使用lambda表达式变换容器内的值的途径。比如，对于数组，就可以通过map转换值，返回包含新值的新数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;<span class="comment">//存储任意类型值的简单类型</span></span><br><span class="line">    <span class="built_in">this</span>._value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// map :: (A -&gt; B) -&gt; A -&gt; B</span></span><br><span class="line">  <span class="function"><span class="title">map</span>(<span class="params">f</span>)</span> &#123; <span class="comment">//用一个函数来 map 该类型（就像数组一样）</span></span><br><span class="line">    <span class="keyword">return</span> f(<span class="built_in">this</span>.val);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Wrapper (&#x27;</span> + <span class="built_in">this</span>.value + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wrap = <span class="function">(<span class="params">val</span>) =&gt;</span> <span class="keyword">new</span> Wrapper(val); <span class="comment">//能够根据值快速创建Wrapper 的帮助函数</span></span><br></pre></td></tr></table></figure>

<p><img src="/posts/9e8f6e6a/0001.jpg"></p>
<p>Wrapper类型使用map安全地访问和操作值。在这种情况下，通过映射 identity 函数就能在容器中提取值</p>
<p>取值得方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrappedValue = wrap(<span class="string">&#x27;Get Functional&#x27;</span>);</span><br><span class="line">wrappedValue.map(R.identity); <span class="comment">//-&gt; &#x27;Get Functional&#x27; &lt;--- 值的提取</span></span><br></pre></td></tr></table></figure>

<p>映射任何函数到该容器，比如记录日志或是变换该值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wrappedValue.map(log);</span><br><span class="line">wrappedValue.map(R.toUpper); <span class="comment">//-&gt; &#x27;GET FUNCTIONAL&#x27; &lt;--- 对内部值应用函数</span></span><br></pre></td></tr></table></figure>

<p>现在所有得对值操作都与要通过<code>map</code>方法先伸入到容器中取值，可以说得到了一定得保护，但现在还没有对<code>null</code>,和<code>undefined</code>得处理</p>
<p>当初始化一个空值得时候</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrappedNull = wrap(<span class="literal">null</span>);</span><br><span class="line">wrappedNull.map(doWork); <span class="comment">// doWork 被赋予了空值检查的责任</span></span><br></pre></td></tr></table></figure>

<p>不应该通过<code>dowork</code>来检查，完全可以交给Wrapper类型来做错误处理。换句话说，可以在调用函数之前，检查<code>null</code>、空字符串或者负数，等等。因此，<code>Wrapper.map</code>的语义就由具体的<code>Wrapper</code>类型来确定。</p>
<p>map的变种——fmap</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fmap :: (A -&gt; B) -&gt; Wrapper[A] -&gt; Wrapper[B]</span></span><br><span class="line">Wrapper.prototype.fmap = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> wrap(f(<span class="built_in">this</span>.val)); <span class="comment">// 先将返回值包裹到容器中，再返回给调用者</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>fmap知道如何在上下文中应用函数值。它会先打开该容器，应用函数到值，最后把返回的值包裹到一个新的同类型容器中。拥有这种函数的类型称为Functor。</p>
<h5 id="Functor定义"><a href="#Functor定义" class="headerlink" title="Functor定义"></a>Functor定义</h5><p>Functor 只是一个可以将函数应用到它包裹的值上，并将结果再包裹起来的数据结构。下面是fmap的一般定义：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmap :: (A -&gt; B) -&gt; Wrapper(A) -&gt; Wrapper(B) // Wrapper 可以是任何容器类型</span><br></pre></td></tr></table></figure>

<p>fmap函数接受一个从A-&gt;B的函数，以及一个Wrapper(A) Functor，然后返回包裹着结果的新FunctorWrapper(B)。下图显示了用increment函数作为A-&gt;B的映射函数，只是这里的A和B为同一类型。</p>
<p><img src="/posts/9e8f6e6a/0002.jpg"></p>
<p>一个简单得例子</p>
<p>通过柯里化初始化一个求和函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus = R.curry(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="keyword">const</span> plus3 = plus(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>把数字2放到wrap中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> two = wrap(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>再调用fmap把plus3映射到容器上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> five = two.fmap(plus3); <span class="comment">//-&gt; Wrapper(5) &lt;--- 返回一个具有上下文包裹的值</span></span><br><span class="line">five.map(R.identity); <span class="comment">//-&gt; 5</span></span><br></pre></td></tr></table></figure>

<p>fmap返回同样类型的结果，可以通过映射R.identity来提取它的值。不过需要注意的是，值会一直在容器中，因此可以 fmap 任意次函数来转换值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two.fmap(plus3).fmap(plus10); <span class="comment">//-&gt; Wrapper(15)</span></span><br></pre></td></tr></table></figure>


<p>Functor有如下一些重要的属性约束。</p>
<ul>
<li>必须是无副作用的。若映射R.identity函数可以获得上下文中相同的值，即可证明Functor是无副作用的：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wrap(<span class="string">&#x27;Get Functional&#x27;</span>).fmap(R.identity); <span class="comment">//-&gt; Wrapper(&#x27;Get Functional&#x27;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>必须是可组合的。这个属性的意思是fmap 函数的组合，与分别fmap函数是一样的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">two.fmap(R.compose(plus3, R.tap(infoLogger))).map(R.identity); <span class="comment">//-&gt; 5</span></span><br></pre></td></tr></table></figure>


<p>Functor的这些属性并不奇怪。遵守这些规则，可以免于抛出异常、篡改元素或者改变函数的行为。<strong>其实际目的只是创建一个上下文或一个抽象，以便可以安全地应用操作到值，而又不改变原始值。这也是map可以将一个数组转换到另一个数组，而不改变原数组的原因。而Functor就是这个概念的推广。</strong></p>
<h4 id="使用Monad函数式地处理错误"><a href="#使用Monad函数式地处理错误" class="headerlink" title="使用Monad函数式地处理错误"></a>使用Monad函数式地处理错误</h4><p>Functor本身并不需要知道如何处理null。例如Ramda中的R.compose，在收到为null的函数引用时就会抛出异常。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> findStudent = R.curry(<span class="function"><span class="keyword">function</span>(<span class="params">db, ssn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> wrap(find(db, ssn)); <span class="comment">//包裹对象获取逻辑，以避免找不到对象所造成的问题</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> getAddress = <span class="function"><span class="keyword">function</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> wrap(student.fmap(R.prop(<span class="string">&#x27;address&#x27;</span>))); <span class="comment">//用 Ramda 的 R.prop()函数来map 对象以获取其地址， 再将结果包裹起来</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> studentAddress = R.compose(</span><br><span class="line">  getAddress,</span><br><span class="line">  findStudent(DB(<span class="string">&#x27;student&#x27;</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回的值是被包裹了两层的address对象</span></span><br><span class="line"></span><br><span class="line">studentAddress(<span class="string">&#x27;444-44-4444&#x27;</span>).map(R.identity).map(R.identity)</span><br></pre></td></tr></table></figure>

<h5 id="Monad：从控制流到数据流"><a href="#Monad：从控制流到数据流" class="headerlink" title="Monad：从控制流到数据流"></a>Monad：从控制流到数据流</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> R = ramda;</span><br><span class="line"><span class="keyword">const</span> Wrap = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._value = value</span><br><span class="line">&#125;</span><br><span class="line">Wrap.of = <span class="function">(<span class="params">value</span>) =&gt;</span> <span class="keyword">new</span> Wrap(value)</span><br><span class="line">Wrap.prototype.fmap = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Wrap.of(f(<span class="built_in">this</span>._value))</span><br><span class="line">&#125;</span><br><span class="line">Wrap.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(<span class="built_in">this</span>._value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(wrap)</span></span><br><span class="line"><span class="comment">// console.log(wrap.map(R.identity))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Empty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Empty.of = <span class="function">() =&gt;</span> <span class="keyword">new</span> Empty();</span><br><span class="line">Empty.prototype.fmap = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">&#125;</span><br><span class="line">Empty.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> empty = Empty.of()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add = R.curry(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="keyword">const</span> plus10 = add(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> isEven = <span class="function">(<span class="params">num</span>) =&gt;</span> <span class="built_in">Number</span>.isFinite(num) &amp;&amp; num % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> half = <span class="function">(<span class="params">num</span>) =&gt;</span> isEven(num) ? Wrap.of(num / <span class="number">2</span>) : empty;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(half(<span class="number">10</span>).fmap(plus10).map(R.identity)) <span class="comment">//15</span></span><br><span class="line"><span class="built_in">console</span>.log(half(<span class="number">9</span>).fmap(plus10).map(R.identity)) <span class="comment">// Empty</span></span><br></pre></td></tr></table></figure>

<p>Monad——为Monadic操作提供抽象接口。<br>Monadic类型——该接口的具体实现。</p>
<p>Monadic类型类似于本章介绍的Wrapper对象。不过每个Monad都有不同的用途，可以定义不同的语义便于确定其行为（例如map或fmap）。使用这些类型可以进行链式或嵌套操作，但都应遵循下列接口定义。</p>
<ul>
<li>类型构造函数——创建Monadic类型（类似于Wrapper的构造函数）。</li>
<li>unit函数——可将特定类型的值放入Monadic结构中（类似于wrap和前面看到的empty函数）。对于Monad的实现来说，该函数也被称为of函数。</li>
<li>bind函数——可以链式操作（这就是Functor的fmap，也被称为flatmap）</li>
<li>join函数——将两层Monadic结构合并成一层。这会对嵌套返回Monad的函数特别有用。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类型构造器</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span> (a) &#123;</span><br><span class="line">        <span class="comment">//unit 函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wrapper(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">map</span>(<span class="params">f</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//bind 函数（ Functor）</span></span><br><span class="line">        <span class="keyword">return</span> Wrapper.of(f(<span class="built_in">this</span>.value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">join</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//压平嵌套的Wrapper</span></span><br><span class="line">        <span class="keyword">if</span> (!(<span class="built_in">this</span>.value <span class="keyword">instanceof</span> Wrapper)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value.join();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//返回一个当前结构的文本描述</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Wrapper (<span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>)`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>join函数用于逐层扁平化嵌套结构，就像剥洋葱一样。这可以用来消除之前用functor时发现的问题</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findObject :: DB -&gt; String -&gt; Wrapper</span></span><br><span class="line"><span class="keyword">const</span> findObject = R.curry(<span class="function"><span class="keyword">function</span>(<span class="params">db, id</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Wrapper.of(find(db, id));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// getAddress :: Student -&gt; Wrapper</span></span><br><span class="line"><span class="keyword">const</span> getAddress = <span class="function"><span class="keyword">function</span>(<span class="params">student</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Wrapper.of(student.map(R.prop(<span class="string">&#x27;address&#x27;</span>)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> studentAddress = R.compose(getAddress, findObject(DB(<span class="string">&#x27;student&#x27;</span>)));</span><br><span class="line">studentAddress(<span class="string">&#x27;444-44-4444&#x27;</span>).join().get(); <span class="comment">// Address</span></span><br></pre></td></tr></table></figure>

<p>Monad通常有更多的操作，这里提及的最小接口只是其整个API的子集。一个Monad本身只是抽象，没有任何实际意义。只有实际的实现类型才有丰富的功能。幸运的是，大多数函数式编程的代码只用一些常用的类型就可以消除大量的样板代码，同时还能完成同样的工作。下面来看丰富的Monad实例：Maybe、Either和IO。</p>
<h5 id="使用Maybe-Monad和Either-Monad来处理异常"><a href="#使用Maybe-Monad和Either-Monad来处理异常" class="headerlink" title="使用Maybe Monad和Either Monad来处理异常"></a>使用Maybe Monad和Either Monad来处理异常</h5><p>除了用来包装有效值，Monadic的结构也可用于建模null或undefined。函数式编程通常使用Maybe和Either来做下列事情。</p>
<ul>
<li>隔离不纯。</li>
<li>合并判空逻辑。</li>
<li>避免异常。</li>
<li>支持函数组合。</li>
<li>中心化逻辑，用于提供默认值。</li>
</ul>
<h6 id="用Maybe合并判空"><a href="#用Maybe合并判空" class="headerlink" title="用Maybe合并判空"></a>用Maybe合并判空</h6><p>Maybe Monad侧重于有效整合null -判断逻辑。Maybe是一个包含两个具体字类型的空类型（标记类型）。</p>
<ul>
<li>Just(value)——表示值的容器。</li>
<li>Nothing()——表示要么没有值或者没有失败的附加信息。当然，还可以应用函数到Nothing上。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> R = ramda;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maybe</span> </span>&#123; <span class="comment">//容器类型（父类）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">just</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Just(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">nothing</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Nothing();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">fromNullable</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a != <span class="literal">null</span> ? Maybe.just(a) :</span><br><span class="line">            Maybe.nothing(); <span class="comment">//由一个可为空的类型创建 Maybe（即构造函数）。如果值为空，则 建一个 Nothing； 否则， 将值存储在 Just 子类型中来表示其存在性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">of</span> (a) &#123;</span><br><span class="line">        <span class="keyword">return</span> Maybe.just(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">isNothing</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">isJust</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Just</span> <span class="keyword">extends</span> <span class="title">Maybe</span> </span>&#123; <span class="comment">//Just 子类型用于处理存在的值</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>._value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>._value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">map</span>(<span class="params">f</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Just.of(f(<span class="built_in">this</span>.value)); <span class="comment">//将映射函数应用于 Just，变换其中的值，并存储回容器中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getOrElse</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value; <span class="comment">//Monad 提供默认的一元操</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">filter</span>(<span class="params">f</span>)</span> &#123;</span><br><span class="line">        Maybe.fromNullable(f(<span class="built_in">this</span>.value) ? <span class="built_in">this</span>.value : <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">isJust</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123; <span class="comment">//返回该结构的文本描述</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Maybe.Just(<span class="subst">$&#123;<span class="built_in">this</span>.value&#125;</span>)`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nothing</span> <span class="keyword">extends</span> <span class="title">Maybe</span> </span>&#123; <span class="comment">//Nothing子类型用于为无值的情况提供保护</span></span><br><span class="line">    <span class="function"><span class="title">map</span>(<span class="params">f</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">            <span class="string">&#x27;Can&quot;t extract the valueof a Nothing.&#x27;</span>); <span class="comment">//任何试图从 Nothing 类型中取值的操作会引发表征错误使用 Monad的异常（后文会予以介绍）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getOrElse</span>(<span class="params">other</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> other; <span class="comment">//忽略值，返回 other</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">filter</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value; <span class="comment">//如果存在的值满足所给的断言，则返回包含值的 Just，否则，返回 Nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">isNothing</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Maybe.Nothing&#x27;</span>; <span class="comment">//返回结构的文本描述</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Maybe显式地抽象对“可空”值（null和undefined）的操作，可让开发者关注更重要的事情。如上述代码所示，Maybe是Just和Nothing的抽象，Just和Nothing各自包含自己的Monadic的实现。正如前面提到的，对于Monadic操作的实现最终取决于具体类型给予的语义。例如，map的行为具体取决于该类型是 Nothing 还是Just</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> find = <span class="function">(<span class="params">db, id</span>) =&gt;</span> (id ? &#123;</span><br><span class="line">    name: <span class="string">&#x27;小红&#x27;</span>,</span><br><span class="line">    address: <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">&#125; : <span class="literal">undefined</span>)</span><br><span class="line"><span class="keyword">const</span> findStudent = R.curry(<span class="function">(<span class="params">db, id</span>) =&gt;</span> Maybe.fromNullable(find(db, id)))</span><br><span class="line"><span class="keyword">const</span> findStudentByDB = findStudent(<span class="string">&#x27;DB&#x27;</span>);</span><br><span class="line"><span class="comment">// 如果有意义得值传入会生成just</span></span><br><span class="line"><span class="built_in">console</span>.log(findStudentByDB(<span class="string">&#x27;id&#x27;</span>).map(R.prop(<span class="string">&#x27;address&#x27;</span>)).value)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有意义得值会生成nothing,如果使用value取值会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(findStudentByDB(<span class="literal">undefined</span>).map(R.prop(<span class="string">&#x27;address&#x27;</span>)).getOrElse(<span class="number">123</span>))</span><br><span class="line"><span class="comment">//赋值时需要注意</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;#student-firstname&#x27;</span>).value = username.getOrElse(<span class="string">&#x27;Enter first name&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>提升函数</strong></p>
<p>很明显，Maybe擅长于集中管理的无效数据的检查，但它没有（双关Nothing）提供关于什么地方出了错的信息。我们需要一个更积极的，可以知道失败原因的解决方案。解决这个问题，要最好的工具是Either monad。</p>
<h6 id="使用Either"><a href="#使用Either" class="headerlink" title="使用Either"></a>使用Either</h6><p>Either跟Maybe略有不同。Either代表的是两个逻辑分离的值a和b，它们永远不会同时出现。这种类型包括以下两种情况。</p>
<p>Left(a)——包含一个可能的错误消息或抛出的异常对象。<br>Right(b)——包含一个成功的值。</p>
<p>Either通常操作右值，这意味着在容器上映射函数总是在Right(b)子类型上执行。它类似于Maybe的Just分支。</p>
<p>Either的常见用法是为失败的结果提供更多的信息。在不可恢复的情况下，左侧可以包含一个合适的异常对象</p>
<p>与MayBe 类似，合法值也是主右的</p>
<h6 id="IO-Monad"><a href="#IO-Monad" class="headerlink" title="IO Monad"></a>IO Monad</h6> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">函数式编程</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-algorithm/leetcode/(3)longest-substring-without-repeating-characters"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/4bff4329/"
    >3. 无重复字符的最长子串</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/4bff4329/" class="article-date">
  <time datetime="2020-11-04T12:56:03.000Z" itemprop="datePublished">2020-11-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/Medium/">Medium</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">LeetCode</a></strong></p>
<blockquote>
<p><strong>注意</strong></p>
</blockquote>
<h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> str = s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; s.length; j++) &#123;</span><br><span class="line">            <span class="keyword">var</span> nstr = s[j];</span><br><span class="line">            <span class="keyword">var</span> mark = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">0</span>; k &lt; str.length; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[k] === nstr) &#123;</span><br><span class="line">                    mark = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mark === <span class="literal">false</span>) &#123;</span><br><span class="line">                str += nstr;</span><br><span class="line">                <span class="keyword">if</span> (str.length &gt; len) len = str.length;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.757ex" height="2.451ex" role="img" focusable="false" viewBox="0 -833.2 2544.6 1083.2" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-3-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-3-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-3-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-3-TEX-N-33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path id="MJX-3-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-3-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(1152, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D45B"></use></g><g data-mml-node="mn" transform="translate(600, 363) scale(0.707)"><use xlink:href="#MJX-3-TEX-N-33"></use></g></g><g data-mml-node="mo" transform="translate(2155.6, 0)"><use xlink:href="#MJX-3-TEX-N-29"></use></g></g></g></svg></mjx-container></p>
</li>
<li><p>空间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-3-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-3-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-3-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-3-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-3-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(1152, 0)"><use xlink:href="#MJX-3-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(1652, 0)"><use xlink:href="#MJX-3-TEX-N-29"></use></g></g></g></svg></mjx-container></p>
</li>
</ul>
<h4 id="暴力解法优化"><a href="#暴力解法优化" class="headerlink" title="暴力解法优化"></a>暴力解法优化</h4><p>通过map缓存已经查找过的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> map = &#123;</span><br><span class="line">            length: <span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        map[s[i]] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; s.length; j++) &#123;</span><br><span class="line">            <span class="keyword">var</span> nstr = s[j];</span><br><span class="line">            <span class="keyword">if</span> (!map[nstr]) &#123;</span><br><span class="line">                map[nstr] = <span class="literal">true</span>;</span><br><span class="line">                map.length++;</span><br><span class="line">                <span class="keyword">if</span> (map.length &gt; len) len = map.length</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="5.757ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2544.6 1083.9" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-3-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-3-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-3-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-3-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path><path id="MJX-3-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-3-TEX-N-28"></use></g><g data-mml-node="msup" transform="translate(1152, 0)"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D45B"></use></g><g data-mml-node="mn" transform="translate(600, 363) scale(0.707)"><use xlink:href="#MJX-3-TEX-N-32"></use></g></g><g data-mml-node="mo" transform="translate(2155.6, 0)"><use xlink:href="#MJX-3-TEX-N-29"></use></g></g></g></svg></mjx-container>,</p>
</li>
<li><p>空间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-3-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-3-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-3-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-3-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-3-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-3-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-3-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(1752, 0)"><use xlink:href="#MJX-3-TEX-N-29"></use></g></g></g></svg></mjx-container>,时间换空间</p>
</li>
</ul>
<h4 id="窗口移动"><a href="#窗口移动" class="headerlink" title="窗口移动"></a>窗口移动</h4><ul>
<li><p>如果下一个字符和之前的字符重复，则重复字符之前的字符都被舍弃</p>
</li>
<li><p>每次读取新字符，判断一次当前位置到舍弃位置的长度是否比之前的总长度大</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&#x27; &#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> map = &#123;</span><br><span class="line">        start: <span class="number">0</span>,</span><br><span class="line">        end: <span class="number">0</span>,</span><br><span class="line">        len: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[s[i]] !== <span class="literal">undefined</span> &amp;&amp; map[s[i]] &gt; map.start) &#123;</span><br><span class="line">            map.start = map[s[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        map[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">        map.end = i + <span class="number">1</span>;</span><br><span class="line">        map.len = <span class="built_in">Math</span>.max(map.end - map.start, map.len)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-2-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-2-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(1752, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g></g></g></svg></mjx-container>,</p>
</li>
<li><p>空间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-1-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(1752, 0)"><use xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container>,时间换空间</p>
</li>
</ul>
<h4 id="优化窗口移动"><a href="#优化窗口移动" class="headerlink" title="优化窗口移动"></a>优化窗口移动</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(),</span><br><span class="line">        <span class="comment">//i为上面方法的start指针</span></span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        j = <span class="number">0</span>,</span><br><span class="line">        max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; s.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.has(s[j])) &#123;</span><br><span class="line">            <span class="comment">//如果存在，当前这个值对应的索引不能比start指针小</span></span><br><span class="line">            i = <span class="built_in">Math</span>.max(map.get(s[j]) + <span class="number">1</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(s[j], j);</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, j - i + <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(map, i, max);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-javascript/fp/(4)模块化且可重用的代码"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/119b719a/"
    >4.模块化且可重用的代码</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/119b719a/" class="article-date">
  <time datetime="2020-11-03T00:56:22.000Z" itemprop="datePublished">2020-11-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>函数链与函数管道的比较<br>Ramda.js 函数库<br>柯里化、部分应用（partial application）和函数绑定<br>通过函数式组合构建模块化程序<br>利用函数组合子增强程序的控制流</p>
<p>先将问题分解成较小的部分，再重建这些部分以形成整体的解决方案。</p>
<h4 id="方法链与函数管道的比较"><a href="#方法链与函数管道的比较" class="headerlink" title="方法链与函数管道的比较"></a>方法链与函数管道的比较</h4><p>Haskell中定义函数的符号。该符号先给出了函数的名称，随后用一个操作符来设置函数的输入和输出类型</p>
<p><img src="/posts/119b719a/0001.jpg"></p>
<h4 id="方法链接（紧耦合，有限的表现力）"><a href="#方法链接（紧耦合，有限的表现力）" class="headerlink" title="方法链接（紧耦合，有限的表现力）"></a>方法链接（紧耦合，有限的表现力）</h4><p>它与方法所属的对象紧紧地耦合在一起，限制链中可以使用的方法数量，也就限制了代码的表现力。这样就只能够使用由Lodash提供的操作，而无法轻松地将不同函数库的（或自定义的）函数连接在一起。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_.chain(names)</span><br><span class="line">.filter(isValid) <span class="comment">//每一个“点”后只能调用 Lodash 提供的方法</span></span><br><span class="line">.map(<span class="function"><span class="params">s</span> =&gt;</span> s.replace(<span class="regexp">/_/</span>, <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">.uniq()</span><br><span class="line">.map(_.startCase)</span><br><span class="line">.sort()</span><br><span class="line">.value();</span><br></pre></td></tr></table></figure>

<p><img src="/posts/119b719a/0002.jpg"></p>
<p><strong>函数的管道化（松耦合，灵活）</strong></p>
<p><img src="/posts/119b719a/0003.jpg"></p>
<p>方法链接通过对象的方法紧密连接；而管道以函数作为组件，将函数的输入和输出松散地连接在一起。但是，为了实现管道，被连接的函数必须在元数（arity）和类型上相互兼容。</p>
<p>函数式编程将管道视为构建程序的唯一方法.</p>
<p>对于不同的任务，问题的定义与解决方案间总是存在很大的差异。因此，特定的计算必须在特定的阶段进行。这些阶段由不同的函数表征，而所选函数的输入和输出需要满足以下两个兼容条件。</p>
<p><strong>类型=&gt;函数的返回类型必须与接收函数的参数类型相匹配。</strong></p>
<p><strong>元数=&gt;接收函数必须声明至少一个参数才能处理上一个函数的返回值。</strong></p>
<p><strong>元组</strong></p>
<p>对传入的参数进行参数类型，和个数的校验，可以用TS替代</p>
<ul>
<li>不可变的——一旦创建，就无法改变一个元组的内部内容。</li>
<li>避免创建临时类型——元组可以将可能毫不相关的数据相关联。而定义和实例化一些仅用于数据分组的新类型使得模型复杂并令人费解。</li>
<li>避免创建异构数组——包含不同类型元素的数组使用起来颇为困难，因为会导致代码中充满大量的防御性类型检查。传统上，数组意在存储相同类型的对象。</li>
</ul>
<h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><p>要求所有参数都被明确地定义，因此当使用部分参数调用时，它会返回一个新的函数，在真正运行之前等待外部提供其余的参数。</p>
<p>R._curry1</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry1</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 判断a是否为占位符</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span> || _isPlaceholder(a)) &#123;</span><br><span class="line">            <span class="keyword">return</span> f1</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 多余的参数也可以传入</span></span><br><span class="line">            <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="部分应用和函数绑定"><a href="#部分应用和函数绑定" class="headerlink" title="部分应用和函数绑定"></a>部分应用和函数绑定</h4><ul>
<li><p>柯里化在每次分步调用时都会生成嵌套的一元函数。在底层，函数的最终结果是由这些一元函数的逐步组合产生的。同时，curry的变体允许同时传递一部分参数。因此，可以完全控制函数求值的时间与方式。</p>
</li>
<li><p>部分应用将函数的参数与一些预设值绑定（赋值），从而产生一个拥有更少参数的新函数。该函数的闭包中包含了这些已赋值的参数，在之后的调用中被完全求值。</p>
</li>
</ul>
<h4 id="延迟函数绑定"><a href="#延迟函数绑定" class="headerlink" title="延迟函数绑定"></a>延迟函数绑定</h4><p>当期望目标函数使用某个所属对象来执行时，使用函数绑定来设置上下文对象就变得尤为重要。例如，浏览器中的setTimeout和setInterval等函数，如果不将this的引用设为全局上下文，即window对象，是不能正常工作的。传递undefined在运行时正确设置它们的上下文。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Scheduler = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> delayedFn = _.bind(<span class="built_in">setTimeout</span>, <span class="literal">undefined</span>, _, _);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    delay5: _.partial(delayedFn, _, <span class="number">5000</span>),</span><br><span class="line">    delay10: _.partial(delayedFn, _, <span class="number">10000</span>),</span><br><span class="line">    delay: _.partial(delayedFn, _, _)</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">Scheduler.delay5(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  consoleLog(<span class="string">&#x27;Executing After 5 seconds!&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.compose = R.compose;</span><br><span class="line"><span class="keyword">const</span> cleanInput = checkLengthSsn.compose(normalize).compose(trim);</span><br></pre></td></tr></table></figure>

<p><strong>对副作用的处理是，拆分副作用的函数，并且固定副作用函数的参数</strong></p>
<h4 id="point-free编程"><a href="#point-free编程" class="headerlink" title="point-free编程"></a>point-free编程</h4><p>使用compose（或者pipe）就意味着永远不必再声明参数了（称为函数的points），这无疑会使代码更加声明式、更加简洁，或更加point-free。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R.compose(first, getName, reverse, sortByGrade, combine);</span><br></pre></td></tr></table></figure>

<p>point-free编程使JavaScript的函数式代码更接近于Haskell和UNIX的理念。它可以用来提高抽象度，促使开发者关注高级组件的组合，而不是低级的函数求值的细节。柯里化在这里也起着很重要的作用，因为它能够灵活地部分定义一个只差最后一个参数的内联函数。这种编码风格也被称为Tacit编程。</p>
<p><strong>在将组合改为这种编码风格时，要记住，过度的使用会使得程序晦涩且令人费解。</strong></p>
<h4 id="组合子"><a href="#组合子" class="headerlink" title="组合子"></a>组合子</h4><p>组合器是一些可以组合其他函数（或其他组合子），并作为控制逻辑运行的高阶函数。组合子通常不声明任何变量，也不包含任何业务逻辑，它们旨在管理函数式程序的流程。除了compose和pipe，还有无数的组合子，一些最常见的组合子如下。</p>
<ul>
<li>identity（I-combinator）</li>
</ul>
<p>为以函数为参数的更高阶函数提供数据，如之前清单4.12中的point-free代码。<br>在单元测试的函数组合器控制流中作为简单的函数结果来进行断言。例如，可以使用identity函数来编写compose的单元测试。<br>函数式地从封装类型中提取数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//identity :: (a) -&gt; a</span></span><br></pre></td></tr></table></figure>

<ul>
<li>tap（K-组合子）</li>
</ul>
<p>该函数接收一个输入对象a和一个对a执行指定操作的函数。它使用提供的对象调用给定的函数，然后再返回该对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tap</span>(<span class="params">fn, x</span>) </span>&#123;</span><br><span class="line">  fn(x);</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>alt （OR-组合子） alternation</li>
</ul>
<p>alt组合子能够在提供函数响应的默认行为时执行简单的条件逻辑。该组合器以两个函数为参数，如<br>果第一个函数返回值已定义（即，不是false、null或undefined)</p>
<p>用于处理if else 逻辑</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> alt = <span class="function"><span class="keyword">function</span> (<span class="params">func1, func2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func1(val) || func2(val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>seq（S-组合子） sequence</li>
</ul>
<p>seq组合子用于遍历函数序列。它以两个或更多的函数作为参数并返回一个新的函数，<strong>会用相同的值顺序调用所有这些函数</strong></p>
<p>seq组合子不会返回任何值，只会一个一个地执行一系列操作。如果要将其嵌入函数组合之间，可以使用R.tap将它与其余部分进行桥接。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> seq = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="regexp">/*funcs*/</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> funcs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      funcs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      fn(val);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>fork（join）组合子</li>
</ul>
<p><img src="/posts/119b719a/0004.jpg"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fork = <span class="function"><span class="keyword">function</span>(<span class="params">join, func1, func2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> join(func1(val), func2(val));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eqMedianAverage = fork(R.equals, R.median, R.mean);</span><br><span class="line">eqMedianAverage([<span class="number">80</span>, <span class="number">90</span>, <span class="number">100</span>])); <span class="comment">//-&gt; True</span></span><br><span class="line">eqMedianAverage([<span class="number">81</span>, <span class="number">90</span>, <span class="number">100</span>])); <span class="comment">//-&gt; False</span></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>用于连接可重用的、模块化的、组件化程序的函数链与管道。</li>
<li>Ramda.js是一个功能强大的函数库，适用于函数的柯里化与组合。</li>
<li>可以通过部分求值和柯里化来减少函数元数，利用对参数子集的部分求值将函数转化为一元函数。</li>
<li>可以将任务分解为多个简单的函数，再通过组合来获得整个解决方案。</li>
<li>以point-free的风格编写，并用函数组合子来组织的程序控制流，可解决现实问题。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">函数式编程</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-javascript/basic/generator_async"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/da10b766/"
    >Generator 异步</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/da10b766/" class="article-date">
  <time datetime="2020-11-02T01:13:11.000Z" itemprop="datePublished">2020-11-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>es6 之前实现异步的方法</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<p>Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p>
<p>使用指针对象的throw方法抛出的错误，可以被函数体内的try…catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next();</span><br><span class="line">g.throw(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>

<h4 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h4><p>虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&#x27;https://api.github.com/users/github&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Thunk-函数的含义"><a href="#Thunk-函数的含义" class="headerlink" title="Thunk 函数的含义"></a>Thunk 函数的含义</h4><p>编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。</p>
<h4 id="JavaScript-语言的-Thunk-函数"><a href="#JavaScript-语言的-Thunk-函数" class="headerlink" title="JavaScript 语言的 Thunk 函数"></a>JavaScript 语言的 Thunk 函数</h4><p>“传值调用”（call by value），即在进入函数体之前，就计算x + 5的值（等于 6），再将这个值传入函数f。C 语言就采用这种策略。</p>
<p>“传名调用”（call by name），即直接将表达式x + 5传入函数体，只在用到它的时候求值。Haskell 语言采用这种策略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFile(fileName, callback);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(callback);</span><br></pre></td></tr></table></figure>


<h4 id="Thunkify"><a href="#Thunkify" class="headerlink" title="Thunkify"></a>Thunkify</h4><p>增加了重复执行的判断</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunkify</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">      args[i] = <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> called;</span><br><span class="line"></span><br><span class="line">      args.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        done.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        fn.apply(ctx, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        done(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="基于Thunk自动流程管理"><a href="#基于Thunk自动流程管理" class="headerlink" title="基于Thunk自动流程管理"></a>基于Thunk自动流程管理</h4><ul>
<li>实现自动执行，一定会自动调用<code>Generator</code>函数执行后的<code>next()</code>方法</li>
</ul>
<p>通过<code>while</code>的判断是否需要执行下一步</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> g = fn();</span><br><span class="line">    <span class="keyword">let</span> res = g.next();</span><br><span class="line">    <span class="keyword">while</span> (res.value) &#123;</span><br><span class="line">        res = g.next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>

<p>结合函数式编程的思想，这里不应该通过循环实现，应该递归调用，考虑创建一个子函数 <code>next</code>用于递归调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> g = fn();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> res = g.next();</span><br><span class="line">        <span class="keyword">if</span> (!res.done) next()</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>

<p>有返回值的情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> g = fn();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> res = g.next(val);</span><br><span class="line">        <span class="keyword">if</span> (!res.done) next(res.value)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> b = <span class="keyword">yield</span> a * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="keyword">yield</span> b * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> c * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>

<p>内部的next函数就是 Thunk 的回调函数。next函数先将指针移到 Generator 函数的下一步（gen.next方法），然后判断 Generator 函数是否结束（result.done属性），如果没结束，就将next函数再传入 Thunk 函数（result.value属性），否则就直接退出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Thunk = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.call(<span class="built_in">this</span>, ...args, callback);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFileThunk1 = Thunk(fs.readFile)(<span class="string">&#x27;./1.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> readFileThunk2 = Thunk(fs.readFile)(<span class="string">&#x27;./2.txt&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> readFileThunk3 = Thunk(fs.readFile)(<span class="string">&#x27;./3.txt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> g = fn();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    <span class="keyword">const</span> res = g.next(data)</span><br><span class="line">    <span class="keyword">if</span> (!res.done) res.value(next)</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> readFileThunk1;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">yield</span> readFileThunk2;</span><br><span class="line">  <span class="keyword">const</span> c = <span class="keyword">yield</span> readFileThunk3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(run(g));</span><br></pre></td></tr></table></figure>

<h4 id="基于Promise的自动执行器"><a href="#基于Promise的自动执行器" class="headerlink" title="基于Promise的自动执行器"></a>基于Promise的自动执行器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(path, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> reject(err);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> g = fn();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = g.next(data);</span><br><span class="line">    <span class="keyword">if</span> (!res.done) res.value.then(<span class="function"><span class="params">data</span> =&gt;</span> next(data));</span><br><span class="line">    <span class="keyword">return</span> res.value;</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">yield</span> readFile(<span class="string">&#x27;./1.txt&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">yield</span> readFile(<span class="string">&#x27;./2.txt&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> c = <span class="keyword">yield</span> readFile(<span class="string">&#x27;./3.txt&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;end&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">run(g)</span><br></pre></td></tr></table></figure>

<h4 id="co的实现"><a href="#co的实现" class="headerlink" title="co的实现"></a>co的实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 统一返回Promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//co 先检查参数gen是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为resolved。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">&#x27;function&#x27;</span>) gen = gen.apply(ctx, args);</span><br><span class="line">        <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">return</span> resolve(gen);</span><br><span class="line">        onFulfilled();</span><br><span class="line">        <span class="comment">//co 将 Generator 函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> ret;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ret = gen.next(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">            next(ret);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> ret;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ret = gen.throw(err);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="keyword">return</span> reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">            next(ret);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ret.done) <span class="keyword">return</span> resolve(ret.value);</span><br><span class="line">            <span class="comment">//确保每一步的返回值，是 Promise 对象。</span></span><br><span class="line">            <span class="keyword">var</span> value = toPromise.call(ctx, ret.value);</span><br><span class="line">            <span class="comment">//使用then方法，为返回值加上回调函数，然后通过onFulfilled函数再次调用next函数。</span></span><br><span class="line">            <span class="keyword">if</span> (value &amp;&amp; isPromise(value)) <span class="keyword">return</span> value.then(onFulfilled, onRejected);</span><br><span class="line">            <span class="comment">//在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为rejected，从而终止执行。</span></span><br><span class="line">            <span class="keyword">return</span> onRejected(<span class="keyword">new</span> <span class="built_in">TypeError</span>(</span><br><span class="line">                <span class="string">&#x27;You may only yield a function, promise, generator, array, or object, &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;but the following object was passed: &quot;&#x27;</span> + <span class="built_in">String</span>(ret.value) + <span class="string">&#x27;&quot;&#x27;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6%E5%9F%BA%E7%A1%80/" rel="tag">ES6基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-algorithm/leetcode/(O53)que-shi-de-shu-zi-lcof"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/28c29680/"
    >O53.0～n-1中缺失的数字</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/28c29680/" class="article-date">
  <time datetime="2020-11-01T11:38:05.000Z" itemprop="datePublished">2020-11-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/">LeetCode</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/LeetCode/Easy/">Easy</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">LeetCode</a></strong></p>
<blockquote>
<p><strong>注意</strong></p>
</blockquote>
<ul>
<li>清楚题目的意思，有一个数字不在数组中，是返回这个数字的本身，而不是索引。<code>[0]</code>长度为1，取值范围是<code>[0,1]</code>其中1不在数组中，所以返回1</li>
</ul>
<h4 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> missingNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> len = nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!==i)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-2-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-2-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(1752, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g></g></g></svg></mjx-container></p>
</li>
<li><p>空间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-2-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(1152, 0)"><use xlink:href="#MJX-2-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(1652, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g></g></g></svg></mjx-container></p>
</li>
</ul>
<h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> missingNumber = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> right = nums.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] === middle) &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = middle<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        middle = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3401 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-2-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path><path id="MJX-2-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path><path id="MJX-2-TEX-I-1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path><path id="MJX-2-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(1152, 0)"><use xlink:href="#MJX-2-TEX-I-1D459"></use></g><g data-mml-node="mi" transform="translate(1450, 0)"><use xlink:href="#MJX-2-TEX-I-1D45C"></use></g><g data-mml-node="mi" transform="translate(1935, 0)"><use xlink:href="#MJX-2-TEX-I-1D454"></use></g><g data-mml-node="mi" transform="translate(2412, 0)"><use xlink:href="#MJX-2-TEX-I-1D45B"></use></g><g data-mml-node="mo" transform="translate(3012, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g></g></g></svg></mjx-container></p>
</li>
<li><p>空间复杂度：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-2-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-2-TEX-I-1D442"></use></g><g data-mml-node="mo" transform="translate(763, 0)"><use xlink:href="#MJX-2-TEX-N-28"></use></g><g data-mml-node="mn" transform="translate(1152, 0)"><use xlink:href="#MJX-2-TEX-N-31"></use></g><g data-mml-node="mo" transform="translate(1652, 0)"><use xlink:href="#MJX-2-TEX-N-29"></use></g></g></g></svg></mjx-container></p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-javascript/fp/(3)轻数据结构,重操作"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/6dd28e9b/"
    >3.轻数据结构,重操作</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/6dd28e9b/" class="article-date">
  <time datetime="2020-11-01T10:19:31.000Z" itemprop="datePublished">2020-11-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>理解程序的控制流<br>更易理解的代码与数据<br>命令抽象函数map、reduce 以及filter<br>Lodash.js 及函数链<br>递归的思考</p>
<h4 id="理解程序的控制流"><a href="#理解程序的控制流" class="headerlink" title="理解程序的控制流"></a>理解程序的控制流</h4><p>程序为实现业务目标所要行进的路径被称为控制流。命令式程序需要通过暴露所有的必要步骤才能极其详细地描述其控制流。</p>
<h4 id="链接方法"><a href="#链接方法" class="headerlink" title="链接方法"></a>链接方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Functional Programming&#x27;</span>.substring(<span class="number">0</span>, <span class="number">10</span>).toLowerCase() + <span class="string">&#x27; is fun&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数式</span></span><br><span class="line">concat(toLowerCase(substring(<span class="string">&#x27;Functional Programming&#x27;</span>, <span class="number">1</span>, <span class="number">10</span>))),<span class="string">&#x27; is fun&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="函数链"><a href="#函数链" class="headerlink" title="函数链"></a>函数链</h4><ul>
<li>lambda表达式</li>
</ul>
<p>lambda表达式适用于函数式的函数定义，因为它总是需要返回一个值。</p>
<ul>
<li>R.map()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">_map</span>(<span class="params">fn, functor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> len = functor.length;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">Array</span>(len);</span><br><span class="line">  <span class="keyword">while</span> (idx &lt; len) &#123;</span><br><span class="line">    result[idx] = fn(functor[idx]);</span><br><span class="line">    idx += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">函数式编程</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-javascript/basic/generator"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/6b643b84/"
    >Generator</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/6b643b84/" class="article-date">
  <time datetime="2020-11-01T08:44:40.000Z" itemprop="datePublished">2020-11-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Generator 函数是 ES6 提供的一种异步编程解决方案</p>
<p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p>调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。</p>
<h4 id="yeild"><a href="#yeild" class="headerlink" title="yeild"></a>yeild</h4><p>yield表达式与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。</p>
<p>yield表达式如果用在另一个表达式之中，必须放在圆括号里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo(<span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>, <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="keyword">yield</span>; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="与-Iterator-接口的关系"><a href="#与-Iterator-接口的关系" class="headerlink" title="与 Iterator 接口的关系"></a>与 Iterator 接口的关系</h4><p>任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g[<span class="built_in">Symbol</span>.iterator]() === g</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h4><p>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</p>
<p><strong>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</strong></p>
<h4 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h4><p><code>for...of</code>循环可以自动遍历 <code>Generator</code> 函数运行时生成的<code>Iterator</code>对象，且此时不再需要调用<code>next</code>方法。</p>
<p>一旦<code>next</code>方法的返回对象的<code>done</code>属性为<code>true</code>，<code>for...of</code>循环就会中止,<code>return</code>语句返回的不包括在<code>for...of</code>循环之中。</p>
<h4 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h4><h4 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h4><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><p><code>next()</code>、<code>throw()</code>、<code>return()</code>这三个方法本质上是同一件事，可以放在一起理解。它们的作用都是让 <code>Generator</code> 函数恢复执行，并且使用不同的语句替换<code>yield</code>表达式。</p>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h4><p>如果在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。</p>
<p>ES6 提供了yield*表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法。</p>
<p>Generator 函数也不能跟new命令一起用，会报错。</p>
<p>首先，生成一个空对象，使用call方法绑定 Generator 函数内部的this。这样，构造函数调用以后，这个空对象就是 Generator 函数的实例对象了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">this</span>.b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">this</span>.c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gen.call(gen.prototype);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: 2, done: false&#125;</span></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: 3, done: false&#125;</span></span><br><span class="line">f.next();  <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br><span class="line">f.a <span class="comment">// 1</span></span><br><span class="line">f.b <span class="comment">// 2</span></span><br><span class="line">f.c <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h4 id="Generator-与状态机"><a href="#Generator-与状态机" class="headerlink" title="Generator 与状态机"></a>Generator 与状态机</h4><p>Generator 之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clock = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Tick!&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Tock!&#x27;</span>);</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>异步操作的同步化表达</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> request(<span class="string">&quot;http://some.url&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="built_in">JSON</span>.parse(result);</span><br><span class="line">    <span class="built_in">console</span>.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  makeAjaxCall(url, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    it.next(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>控制流管理</p>
</li>
<li><p>部署 Iterator 接口</p>
</li>
<li><p>作为数据结构</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6%E5%9F%BA%E7%A1%80/" rel="tag">ES6基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-javascript/fp/(2)高阶Javascript"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/22054a3/"
    >2.进阶</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/22054a3/" class="article-date">
  <time datetime="2020-10-30T04:34:24.000Z" itemprop="datePublished">2020-10-30</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>为什么说JavaScript是适合函数式的编程语言<br>JavaScript语言的多范型开发<br>不可变性和变化的对策<br>理解高阶函数和一等函数<br>闭包和作用域的概念探讨<br>闭包的实际使用</p>
<h4 id="函数式与面向对象"><a href="#函数式与面向对象" class="headerlink" title="函数式与面向对象"></a>函数式与面向对象</h4><p>面向对象的关键是创建继承层次结构（如继承Person的Student对象）并将方法与数据紧密的绑定在一起。函数式编程则更倾向于通过广义的多态函数交叉应用于不同的数据类型，同时避免使用this</p>
<h4 id="属性保护"><a href="#属性保护" class="headerlink" title="属性保护"></a>属性保护</h4><p><img src="/posts/22054a3/0001.jpg"></p>
<p>试用递归来冻结数属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isObject = <span class="function">(<span class="params">val</span>) =&gt;</span> val &amp;&amp; <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepFreeze</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(isObject(obj) <span class="comment">//遍历所有属性并递归调用Object.freeze()（使用第3章介绍的map）</span></span><br><span class="line">    &amp;&amp; !<span class="built_in">Object</span>.isFrozen(obj)) &#123; <span class="comment">//跳过已经冻结过的对象，冻结没有被冻结过的对象</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(obj). <span class="comment">//跳过所有的函数，即使从技术上说，函数也可以被修改，但是我们更希望注意在数据的属性上</span></span><br><span class="line">  forEach(<span class="function"><span class="params">name</span> =&gt;</span> deepFreeze(obj[name])); <span class="comment">//递归地自调用（第3章会介绍递归）</span></span><br><span class="line">    <span class="built_in">Object</span>.freeze(obj); <span class="comment">//冻结根对象</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>R.lensProp</strong> 保证对象属性的不可变性</p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>需要区分表达式（如返回一个值的函数）和语句（如不返回值的函数）。命令式编程和过程式程序大多是由一系列有序的语句组成的，而函数式编程完全依赖于表达式，因此无值函数在该范式下并没有意义。</p>
<ul>
<li><p>一等函数</p>
</li>
<li><p>高阶函数</p>
</li>
</ul>
<h4 id="闭包作用域"><a href="#闭包作用域" class="headerlink" title="闭包作用域"></a>闭包作用域</h4> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">函数式编程</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-javascript/basic/iterator"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/1cf0e843/"
    >Iterator</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/1cf0e843/" class="article-date">
  <time datetime="2020-10-29T14:44:37.000Z" itemprop="datePublished">2020-10-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%9F%BA%E7%A1%80/">基础</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>ES6在原有<code>Array</code>,<code>Object</code>增加了<code>Map</code>,<code>Set</code>,共有4种用于表示集合的数据解构</p>
<p>遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作</p>
<p>Iterator 的作用有三个：</p>
<ul>
<li><p>一是为各种数据结构，提供一个统一的、简便的访问接</p>
</li>
<li><p>二是使得数据结构的成员能够按某种次序排列</p>
</li>
<li><p>三是 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。</p>
</li>
</ul>
<p>Iterator 的遍历过程是这样的。</p>
<ul>
<li><p>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p>
</li>
<li><p>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</p>
</li>
<li><p>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</p>
</li>
<li><p>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</p>
</li>
</ul>
<p>每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。</p>
<h4 id="默认-Iterator-接口"><a href="#默认-Iterator-接口" class="headerlink" title="默认 Iterator 接口"></a>默认 Iterator 接口</h4><p>当使用for…of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p>
<p>ES6 规定，默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性.</p>
<p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。</p>
<p>原生具备 Iterator 接口的数据结构如下。</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。</p>
<h4 id="调用场合"><a href="#调用场合" class="headerlink" title="调用场合"></a>调用场合</h4><ul>
<li><p>解构赋值</p>
</li>
<li><p>扩展运算符</p>
</li>
<li><p>yield*</p>
</li>
</ul>
<p>数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口</p>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如new Map([[‘a’,1],[‘b’,2]])）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
<h4 id="结合Generator函数"><a href="#结合Generator函数" class="headerlink" title="结合Generator函数"></a>结合Generator函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="遍历器对象的-return-，throw"><a href="#遍历器对象的-return-，throw" class="headerlink" title="遍历器对象的 return()，throw()"></a>遍历器对象的 return()，throw()</h4><p>return()方法的使用场合是，如果for…of循环提前退出（通常是因为出错，或者有break语句），就会调用return()方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return()方法。</p>
<p>return()方法必须返回一个对象，这是 Generator 语法决定的。</p>
<p>throw()方法主要是配合 Generator 函数使用，一般的遍历器对象用不到这个方法。</p>
<h4 id="与其他遍历语法"><a href="#与其他遍历语法" class="headerlink" title="与其他遍历语法"></a>与其他遍历语法</h4><p><code>forEach</code>无法中途跳出</p>
<p><code>for...in</code>循环有几个缺点。数组的键名是数字，但是<code>for...in</code>循环是以字符串作为键名“0”、“1”、“2”等等。</p>
<p><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</p>
<p><code>for...of</code>有着同for…in一样的简洁语法，但是没有for…in那些缺点。不同于forEach方法，它可以与break、continue和return配合使用。提供了遍历所有数据结构的统一操作接口。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6%E5%9F%BA%E7%A1%80/" rel="tag">ES6基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-javascript/fp/(1)走进函数式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/e5dd037f/"
    >1.函数式</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/e5dd037f/" class="article-date">
  <time datetime="2020-10-29T01:59:55.000Z" itemprop="datePublished">2020-10-29</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>面向对象编程（OO）通过封装变化使得代码更易理解。</p>
<p>函数式编程（FP）通过最小化变化使得代码更易理解。</p>
<h4 id="函数式思想"><a href="#函数式思想" class="headerlink" title="函数式思想"></a>函数式思想</h4><p>JavaScript是一种拥有很多共享状态的动态语言，用不了多久，代码就会积累足够的复杂性。面向对象的编程思想可以解决一部分问。</p>
<p>我们需要的是一个可以对数据处理，并能处理交互，IO的编程范式，函数式编程在处理数据流转很有帮助，下一步我们希望深入函数式编程的理念，能让其处理异步交互，并且解决代码的复杂性</p>
<p>在应用设计时应该考虑一下几点：</p>
<ul>
<li>可扩展性——我是否需要不断地重构代码来支持额外的功能？</li>
<li>易模块化——如果我更改了一个文件，另一个文件会不会受到影响？</li>
<li>可重用性——是否有很多重复的代码？</li>
<li>可测性——给这些函数添加单元测试是否让我纠结？</li>
<li>易推理性——我写的代码是否非结构化严重并难以推理？</li>
</ul>
<p>使用Javascript语言的其中一个问题是，缺乏一些能够妥当管理状态的原生解构，需要开发人员自身把控。随着复杂度的增高，变得难以控制。</p>
<h4 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h4><p>命令式编程是很具体的告诉计算机如何执行某个任务，而声明式编程是将程序的描述和求值分离。</p>
<h4 id="副作用和纯函数"><a href="#副作用和纯函数" class="headerlink" title="副作用和纯函数"></a>副作用和纯函数</h4><p>纯函数 </p>
<ul>
<li><p>仅取决于提供的输入，而不依赖于任何在函数求值期间或调用间隔时可能变化的隐藏状态和外部状态。</p>
</li>
<li><p>不会造成超出其作用域的变化，例如修改全局对象或引用传递的参数。</p>
</li>
</ul>
<p>副作用的发生情况</p>
<ul>
<li><p>改变一个全局的变量、属性或数据结构。this的使用容易发生问题。</p>
</li>
<li><p>改变一个函数参数的原始值。</p>
</li>
<li><p>处理用户输入。</p>
</li>
<li><p>抛出一个异常，除非它又被当前函数捕获了。</p>
</li>
<li><p>屏幕打印或记录日志。</p>
</li>
<li><p>查询 HTML 文档、浏览器的 cookie或访问数据库。</p>
</li>
</ul>
<h4 id="引用透明和可置换性"><a href="#引用透明和可置换性" class="headerlink" title="引用透明和可置换性"></a>引用透明和可置换性</h4><p>引用透明使得开发者可以用这种系统的甚至是数理的方法来推导程序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">increment();</span><br><span class="line">increment();</span><br><span class="line">print(counter);<span class="comment">//引用不透明,调用期间如果被修改，会影响结果</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus = run(increment,increment);</span><br><span class="line">print(run(<span class="number">0</span>))<span class="comment">//总是为初始值加2</span></span><br></pre></td></tr></table></figure>

<h4 id="存储不可变数据"><a href="#存储不可变数据" class="headerlink" title="存储不可变数据"></a>存储不可变数据</h4><p>JavaScript 开发人员面临的问题都是由大量使用严重依赖外部共享变量的、存在太多分支的以及没有清晰的结构大函数所造成的。</p>
<p>即便是一些由很多文件组成并执行得很成功的应用，也会形成一种共享的可变全局数据网，难以跟踪和调试。</p>
<h4 id="函数式编程的优点"><a href="#函数式编程的优点" class="headerlink" title="函数式编程的优点"></a>函数式编程的优点</h4><ul>
<li><p>促使将任务分解成简单的函数。</p>
</li>
<li><p>使用流式的调用链来处理数据。</p>
</li>
<li><p>通过响应式范式降低事件驱动代码的复杂性。</p>
</li>
</ul>
<h4 id="复杂异步应用中的响应"><a href="#复杂异步应用中的响应" class="headerlink" title="复杂异步应用中的响应"></a>复杂异步应用中的响应</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>使用纯函数的代码绝不会更改或破坏全局状态，有助于提高代码的可测试性和可维护性。</p>
</li>
<li><p>函数式编程采用声明式的风格，易于推理。这提高了应用程序的整体可读性，通过使用组合和lambda表达式使代码更加精简。</p>
</li>
<li><p>集合中的数据元素处理可以通过链接如map和reduce这样的函数来实现。</p>
</li>
<li><p>函数式编程将函数视为积木，通过一等高阶函数来提高代码的模块化和可重用性。</p>
</li>
<li><p>可以利用响应式编程组合各个函数来降低事件驱动程序的复杂性。</p>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag">函数式编程</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> SunZhiqi
      </li>
    </ul>
    <ul>
      <li>
        
        
        <!--  -->
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <!-- <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a> -->
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/logo.png" alt="四月八日"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>帮到你了么朋友</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/kity.min.js"></script>


<script src="/js/kityminder.core.min.js"></script>


<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->

<!-- CanvasBackground -->


    
  </div>
</body>

</html>
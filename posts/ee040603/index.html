<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    图 |  
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/remixicon.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?e6048c3e856b5cbdb1e6ef6e00d5b63d";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-algorithm/structure/(12)图"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  图
</h1>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/ee040603/" class="article-date">
  <time datetime="2020-10-15T04:25:44.000Z" itemprop="datePublished">2020-10-15</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a> / <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">3.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">15 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="图的相关术语"><a href="#图的相关术语" class="headerlink" title="图的相关术语"></a>图的相关术语</h4><p>图是网络结构的抽象模型。是一组由<strong>边</strong>连接的<strong>节点</strong>（或顶点）</p>
<p>任何二元关系都可以用图来表示。</p>
<p>数学上表示为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex" xmlns="http://www.w3.org/2000/svg" width="11.03ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4875.2 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D43A" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q492 659 471 656T418 643T357 615T294 567T236 496T189 394T158 260Q156 242 156 221Q156 173 170 136T206 79T256 45T308 28T353 24Q407 24 452 47T514 106Q517 114 529 161T541 214Q541 222 528 224T468 227H431Q425 233 425 235T427 254Q431 267 437 273H454Q494 271 594 271Q634 271 659 271T695 272T707 272Q721 272 721 263Q721 261 719 249Q714 230 709 228Q706 227 694 227Q674 227 653 224Q646 221 643 215T629 164Q620 131 614 108Q589 6 586 3Q584 1 581 1Q571 1 553 21T530 52Q530 53 528 52T522 47Q448 -22 322 -22Q201 -22 126 55T50 252Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-1-TEX-I-1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path><path id="MJX-1-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path><path id="MJX-1-TEX-I-1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D43A"></use></g><g data-mml-node="mo" transform="translate(1063.8, 0)"><use xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mo" transform="translate(2119.6, 0)"><use xlink:href="#MJX-1-TEX-N-28"></use></g><g data-mml-node="mi" transform="translate(2508.6, 0)"><use xlink:href="#MJX-1-TEX-I-1D449"></use></g><g data-mml-node="mo" transform="translate(3277.6, 0)"><use xlink:href="#MJX-1-TEX-N-2C"></use></g><g data-mml-node="mi" transform="translate(3722.2, 0)"><use xlink:href="#MJX-1-TEX-I-1D438"></use></g><g data-mml-node="mo" transform="translate(4486.2, 0)"><use xlink:href="#MJX-1-TEX-N-29"></use></g></g></g></svg></mjx-container>,<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="1.74ex" height="1.595ex" role="img" focusable="false" viewBox="0 -683 769 705" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D449"></use></g></g></g></svg></mjx-container> 表示一组顶点，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0" xmlns="http://www.w3.org/2000/svg" width="1.729ex" height="1.538ex" role="img" focusable="false" viewBox="0 -680 764 680" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D438"></use></g></g></g></svg></mjx-container> 表示一组边，连接<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex" xmlns="http://www.w3.org/2000/svg" width="1.74ex" height="1.595ex" role="img" focusable="false" viewBox="0 -683 769 705" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g data-mml-node="math"><g data-mml-node="mi"><use xlink:href="#MJX-1-TEX-I-1D449"></use></g></g></g></svg></mjx-container>中的顶点</p>
<p><img src="/posts/ee040603/0001.png"></p>
<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul>
<li><p>由一条边连接在一起的顶点称为<strong>相邻顶点</strong>。比如，A 和B 是相邻的，A 和D 是相邻的，A 和C 是相邻的，A 和E 不是相邻的。</p>
</li>
<li><p>一个顶点的<strong>度</strong>是其相邻顶点的数量。比如，A 和其他三个顶点相连接，因此A 的度为3；E和其他两个顶点相连，因此E 的度为2。</p>
</li>
<li><p><strong>路径</strong>是顶点v1, v2, …, vk 的一个连续序列，其中vi 和vi+1 是相邻的。以上一示意图中的图为例，其中包含路径A B E I 和A C D G。</p>
</li>
<li><p>简单路径要求不包含重复的顶点。举个例子，A D G 是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），<strong>环</strong>也是一个简单路径，比如A D C A（最后一个顶点重新回到A）</p>
</li>
<li><p>如果图中不存在环，则称该图是<strong>无环的</strong>。如果图中每两个顶点间都存在路径，则该图是<strong>连通的</strong>。</p>
</li>
</ul>
<h4 id="有向图-无向图"><a href="#有向图-无向图" class="headerlink" title="有向图 无向图"></a>有向图 无向图</h4><p>图可以是无向的（边没有方向）或是有向的（有向图）。第一张图是无向图，下面这张是有向图</p>
<p><img src="/posts/ee040603/0002.png"></p>
<p>如果图中每两个顶点间在<strong>双向上</strong>都存在路径，则该图是强连通的。例如，C 和D 是强连通的，而A 和B 不是强连通的。</p>
<p>图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值。</p>
<p><img src="/posts/ee040603/0003.png"></p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li><p>搜索图中的一个特定顶点或搜索一条特定边</p>
</li>
<li><p>寻找图中的一条路径（从一个顶点到另一个顶点</p>
</li>
<li><p>寻找两个顶点之间的最短路径，以及环检测。</p>
</li>
</ul>
<h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>每个节点都和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示顶点之间的连接。</p>
<p>如果索引为<code>i</code> 的节点和索引为 <code>j</code> 的节点相邻，则 <code>array[i][j] === 1</code>，否则<code>array[i][j]</code> === 0，如下图所示。</p>
<p><img src="/posts/ee040603/0004.png"></p>
<p>由于不是强连通图（每两个节点间都存在路径），所以数组中有大量的0</p>
<p>给定顶点的相邻顶点，即使该顶点只有一个相邻顶点，我们也不得不迭代一整行。</p>
<p>邻接矩阵表示法不够好的另一个理由是，图中顶点的数量可能会改变，修改二维数组不够灵活。</p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接表由图中每个顶点的相邻顶点列表所组成。</p>
<p>存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。</p>
<p><img src="/posts/ee040603/0005.png"></p>
<p>对大多数问题来说都是更好的选择</p>
<p>但要找出顶点 v 和 w 是否相邻，使用邻接矩阵会比较快</p>
<h4 id="关联矩阵"><a href="#关联矩阵" class="headerlink" title="关联矩阵"></a>关联矩阵</h4><p>关联矩阵中，矩阵的行表示顶点，列表示边。如下图所示，</p>
<p>使用二维数组来表示两者之间的连通性，如果顶点 <code>v</code> 是边 <code>e</code> 的入射点，则 <code>array[v][e] === 1</code></p>
<p>否则，<code>array[v][e] === 0</code></p>
<p><img src="/posts/ee040603/0006.png"></p>
<p>关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存。</p>
<h3 id="创建Graph-类"><a href="#创建Graph-类" class="headerlink" title="创建Graph 类"></a>创建Graph 类</h3><h4 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a>类的结构</h4><ul>
<li><p>图是否有向，默认无无向图 ①</p>
</li>
<li><p>使用一个数组来储存顶点的名字 ②</p>
</li>
<li><p>使用一个字典来储存邻接表，字典将会使用顶点的名字作为键，邻接顶点列表作为值 ③</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">isDirected = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.isDirected = isDirected; <span class="comment">// ①</span></span><br><span class="line">    <span class="built_in">this</span>.vertices = []; <span class="comment">// ②</span></span><br><span class="line">    <span class="built_in">this</span>.adjList = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// ③</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="插入顶点方法"><a href="#插入顶点方法" class="headerlink" title="插入顶点方法"></a>插入顶点方法</h4><ul>
<li><p>如果顶点不存 ④ 在顶点列表中添加节点 ⑤ </p>
</li>
<li><p>在邻接表中为该顶点创建空数组 ⑥</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addVertex</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.vertices.has(v)) &#123; <span class="comment">// ④</span></span><br><span class="line">    <span class="built_in">this</span>.vertices.push(v); <span class="comment">// ⑤ </span></span><br><span class="line">    <span class="built_in">this</span>.adjList.add(v, []); <span class="comment">// ⑥</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建立链接方法"><a href="#建立链接方法" class="headerlink" title="建立链接方法"></a>建立链接方法</h4><ul>
<li><p>如果建立链接的两个点不在顶点列表中，要先填入顶点列表</p>
</li>
<li><p>将 <code>w</code> 加入到 <code>v</code> 的邻接表中，表示添加了一条自顶点 <code>v</code> 到顶点 <code>w</code> 的边</p>
</li>
<li><p>无向图需要添加一条自 <code>w</code> 到 <code>v</code> 的边</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addEdge</span>(<span class="params">v, w</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.adjList.has(v)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.addVertex(v);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.adjList.has(w)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.addVertex(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.adjList.get(v).push(w);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.isDirected) &#123;</span><br><span class="line">    <span class="built_in">this</span>.adjList.get(w).push(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意我们只是往数组里新增元素，因为数组已经在行 ⑥ 被初始化了</p>
</blockquote>
<h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>一个返回顶点列表，另一个返回邻接表</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getVertices</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.vertices;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">getAdjList</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.adjList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">isDirected = <span class="literal">false</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.isDirected = isDirected; <span class="comment">// &#123;1&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.vertices = []; <span class="comment">// &#123;2&#125;</span></span><br><span class="line">    <span class="built_in">this</span>.adjList = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// &#123;3&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addVertex</span>(<span class="params">v</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.vertices.includes(v)) &#123; <span class="comment">// &#123;5&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.vertices.push(v); <span class="comment">// &#123;6&#125;</span></span><br><span class="line">      <span class="built_in">this</span>.adjList.set(v, []); <span class="comment">// &#123;7&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addEdge</span>(<span class="params">v, w</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.adjList.has(v)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.addVertex(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.adjList.has(w)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.addVertex(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.adjList.get(v).push(w);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isDirected) &#123;</span><br><span class="line">      <span class="built_in">this</span>.adjList.get(w).push(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getVertices</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.vertices;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getAdjList</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.adjList;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.vertices.length; i++) &#123; <span class="comment">// &#123;15&#125;</span></span><br><span class="line">      s += <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.vertices[i]&#125;</span> -&gt; `</span>;</span><br><span class="line">      <span class="keyword">const</span> neighbors = <span class="built_in">this</span>.adjList.get(<span class="built_in">this</span>.vertices[i]); <span class="comment">// &#123;16&#125;</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; neighbors.length; j++) &#123; <span class="comment">// &#123;17&#125;</span></span><br><span class="line">        s += <span class="string">`<span class="subst">$&#123;neighbors[j]&#125;</span> `</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      s += <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// &#123;18&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> graph = <span class="keyword">new</span> Graph();</span><br><span class="line"><span class="keyword">const</span> myVertices = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>]; <span class="comment">// &#123;12&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; myVertices.length; i++) &#123; <span class="comment">// &#123;13&#125;</span></span><br><span class="line">  graph.addVertex(myVertices[i]);</span><br><span class="line">&#125;</span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// &#123;14&#125;</span></span><br><span class="line"></span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;H&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(graph.toString());</span><br></pre></td></tr></table></figure>

<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>有两种算法可以对图进行遍历：<strong>广度优先搜索（breadth-first search，BFS）</strong> 和 <strong>深度优先搜索（depth-first search，DFS）</strong></p>
<p>图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环，等等。</p>
<p>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。</p>
<p>完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。</p>
<p>为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。</p>
<p>广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构，如下表所示。</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>数据结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>深度优先搜索</td>
<td>栈</td>
<td>将顶点存入栈，顶点是沿着路径被探索的，存在新的相邻顶点就去访问</td>
</tr>
<tr>
<td>广度优先搜索</td>
<td>队列</td>
<td>将顶点存入队列，最先入队列的顶点先被探索</td>
</tr>
</tbody></table>
<h4 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h4><p>队列结构是广度优先遍历的精髓</p>
<p>从起点节点开始相邻的节点会被添加到队列中</p>
<p>因为队列有先进先出的性质，所以相邻的节点在遍历队列的时候会先被拿到，从而是实现了广度优先遍历</p>
<p>下一个关键点是如何知道节点没有被重复访问，解决办法是给访问过的节点打一个标记，如果下次访问相同的节点就跳过</p>
<p><code>WHITE</code>: 表示没有被访问过 <code>GARY</code>: 访问过但是没有遍历子节点 <code>BALCK</code>: 节点和子结点都被访问过</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startVertex 指定遍历的起点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">breadthFirstSearch</span>(<span class="params">graph, startVertex, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到节点列表</span></span><br><span class="line">  <span class="keyword">const</span> vertices = graph.getVertices()</span><br><span class="line">  <span class="comment">// 拿到邻接表结构</span></span><br><span class="line">  <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">  <span class="comment">//标记是否访问过 默认所有节点都是白色没有访问过</span></span><br><span class="line">  <span class="keyword">const</span> color = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class="line">    color[vertices[i]] = <span class="string">&quot;WHITE&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个队列</span></span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  queue.push(startVertex);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">    <span class="keyword">const</span> nabor = adjList.get(node)</span><br><span class="line">    color[node] = <span class="string">&#x27;GARY&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> nabor) &#123;</span><br><span class="line">      <span class="keyword">if</span>(color[v] === <span class="string">&#x27;WHITE&#x27;</span>)&#123;</span><br><span class="line">        color[v] = <span class="string">&quot;GARY&quot;</span></span><br><span class="line">        queue.push(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    color[v] = <span class="string">&quot;BLACK&quot;</span></span><br><span class="line">    <span class="built_in">console</span>.log(node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">breadthFirstSearch(graph,myVertices[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h5 id="使用广度优先寻找最短路径"><a href="#使用广度优先寻找最短路径" class="headerlink" title="使用广度优先寻找最短路径"></a>使用广度优先寻找最短路径</h5><p>因为使用了广度优先，所以会先访问距离为1的节点，然后是距离为2的节点，路径长的那一条线路，因为同一个节点被访问过，所以不会被记录，从而记录的都是每个节点到起点的最短路径</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// startVertex 指定遍历的起点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">breadthFirstSearch</span>(<span class="params">graph, startVertex, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到节点列表</span></span><br><span class="line">  <span class="keyword">const</span> vertices = graph.getVertices()</span><br><span class="line">  <span class="comment">// 拿到邻接表结构</span></span><br><span class="line">  <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">  <span class="comment">//标记是否访问过 默认所有节点都是白色没有访问过</span></span><br><span class="line">  <span class="keyword">const</span> color = &#123;&#125;</span><br><span class="line">  <span class="comment">// 距离</span></span><br><span class="line">  <span class="keyword">const</span> distance = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 回溯节点 标识上一个节点是什么</span></span><br><span class="line">  <span class="keyword">const</span> predecessors = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertices.length; i++) &#123;</span><br><span class="line">    color[vertices[i]] = <span class="string">&quot;WHITE&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建一个队列</span></span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  queue.push(startVertex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化默认距离，和回溯节点</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; vertices.length; i++)&#123;</span><br><span class="line">    distance[vertices[i]] = <span class="number">0</span>;</span><br><span class="line">    predecessors[vertices[i]] = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">    <span class="keyword">const</span> nabor = adjList.get(node)</span><br><span class="line">    color[node] = <span class="string">&#x27;GARY&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> nabor) &#123;</span><br><span class="line">      <span class="keyword">if</span> (color[v] === <span class="string">&#x27;WHITE&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 上级节点的最短路进</span></span><br><span class="line">        distance[v] = distance[node] + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 指定当前节点的上级节点</span></span><br><span class="line">        predecessors[v] = node;</span><br><span class="line">        color[v] = <span class="string">&quot;GARY&quot;</span></span><br><span class="line">        queue.push(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    distance,</span><br><span class="line">    predecessors</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">breadthFirstSearch(graph, myVertices[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>通过生成的前溯表以及所有的节点我们可以生成每个节点到头节点的最短路径</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历每一个节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> myVertices) &#123;</span><br><span class="line">  <span class="keyword">const</span> path = [];</span><br><span class="line">  <span class="comment">// 如果当前节点不是头节点，就存入上一个节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> w = v; w !== <span class="literal">null</span>; w = shortestPathA.predecessors[w]) &#123;</span><br><span class="line">    path.push(w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> s = path.pop();</span><br><span class="line">  <span class="comment">//反向拼接每一个节点</span></span><br><span class="line">  <span class="keyword">while</span> (path.length) &#123;</span><br><span class="line">    s += <span class="string">&#x27;-&#x27;</span> + path.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>因为深度优先需要把一条路径遍历到底，所以拿到的节点需要继续遍子结点</p>
<p>所以深度优先的精髓就是栈的结构，拿到的子结点加入栈中，由于栈先进先出可以继续访问下层的子结点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">graph</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vertices = graph.getVertices();</span><br><span class="line">  <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">  <span class="keyword">const</span> color = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> vertices) &#123;</span><br><span class="line">    color[v] = <span class="string">&quot;WHITE&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 栈结构</span></span><br><span class="line">  <span class="keyword">const</span> stack = [];</span><br><span class="line">  stack.unshift(vertices[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// 如果栈不为空就继续遍历</span></span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> v = stack.shift();</span><br><span class="line">    <span class="comment">// 如果没有访问过就访问子结点</span></span><br><span class="line">    <span class="keyword">if</span> (color[v] === <span class="string">&quot;WHITE&quot;</span>) &#123;</span><br><span class="line">      color[v] = <span class="string">&#x27;GARY&#x27;</span>;</span><br><span class="line">      <span class="comment">// 获取到子结点 放入栈中</span></span><br><span class="line">      <span class="keyword">const</span> nabor = adjList.get(v);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> vn <span class="keyword">of</span> nabor.reverse()) &#123;</span><br><span class="line">        stack.unshift(vn);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(graph)</span><br></pre></td></tr></table></figure>

<p>这种写法可以实现遍历，但是不方便统计某个节点的子结点是否全部遍历，也就是置成<code>BLACK</code></p>
<p>另一个关键点，函数递归调用也可以调用栈，保存每个函数的调用帧, 所以深度优先也常用递归来解决</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">graph</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vertices = graph.getVertices();</span><br><span class="line">  <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">  <span class="keyword">const</span> color = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> vertices) &#123;</span><br><span class="line">    color[v] = <span class="string">&quot;WHITE&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  depthFirstSearch(vertices[<span class="number">0</span>], adjList, color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> depthFirstSearch = <span class="function"><span class="keyword">function</span> (<span class="params">v, adjList, color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nabor = adjList.get(v);</span><br><span class="line">  <span class="keyword">if</span> (color[v] === <span class="string">&#x27;WHITE&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line"></span><br><span class="line">    color[v] = <span class="string">&#x27;GARY&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> vn <span class="keyword">of</span> nabor) &#123;</span><br><span class="line">      depthFirstSearch(vn, adjList, color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子结点遍历完成之后标记为黑色</span></span><br><span class="line">    color[v] === <span class="string">&#x27;BLACK&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(graph)</span><br></pre></td></tr></table></figure>

<h5 id="加入节点信息"><a href="#加入节点信息" class="headerlink" title="加入节点信息"></a>加入节点信息</h5><p>在遍历图的时候加入更多的节点信息</p>
<p>1.每个节点的发现时间，到达某个节点经历的步数<br>2.每个节点的访问时间，某个节点所有子结点都被访问过的步数<br>3.节点的前溯节点表</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> depthFirstSearch = <span class="function"><span class="keyword">function</span> (<span class="params">v, adjList, color, find, visit, back, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nabor = adjList.get(v);</span><br><span class="line">  <span class="keyword">if</span> (color[v] === <span class="string">&#x27;WHITE&#x27;</span>) &#123;</span><br><span class="line">    find[v] = ++(time.t);</span><br><span class="line">    color[v] = <span class="string">&#x27;GARY&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> vn <span class="keyword">of</span> nabor) &#123;</span><br><span class="line">      back[vn] = v;</span><br><span class="line">      depthFirstSearch(vn, adjList, color, find, visit, back, time);</span><br><span class="line">    &#125;</span><br><span class="line">    color[v] === <span class="string">&#x27;BLACK&#x27;</span></span><br><span class="line">    visit[v] = ++(time.t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">graph,</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vertices = graph.getVertices();</span><br><span class="line">  <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">  <span class="keyword">const</span> color = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> find = &#123;&#125;;<span class="comment">// 发现时间</span></span><br><span class="line">  <span class="keyword">const</span> visit = &#123;&#125;;<span class="comment">// 访问时间</span></span><br><span class="line">  <span class="keyword">const</span> back = &#123;&#125;;<span class="comment">// 回溯时间</span></span><br><span class="line">  <span class="keyword">const</span> time = &#123; <span class="attr">t</span>: <span class="number">0</span> &#125;<span class="comment">//用于计时</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> vertices) &#123;</span><br><span class="line">    color[v] = <span class="string">&quot;WHITE&quot;</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    find[v] = <span class="number">0</span>;</span><br><span class="line">    visit[v] = <span class="number">0</span>;</span><br><span class="line">    back[v] = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  depthFirstSearch(vertices[<span class="number">0</span>], adjList, color, find, visit, back, time);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    find, visit, back, time</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(graph)</span><br></pre></td></tr></table></figure>

<h5 id="通过深度优先搜索拓扑排序"><a href="#通过深度优先搜索拓扑排序" class="headerlink" title="通过深度优先搜索拓扑排序"></a>通过深度优先搜索拓扑排序</h5><p>有些任务需要按顺序执行，而且不同的任务会公用一些子任务，编排这些有序任务被成为拓扑排序</p>
<p><img src="/posts/ee040603/0007.png"></p>
<p>这些任务形成了有向无环图，通过上面一节添加的节点信息，生成这些任务的执行顺序</p>
<p>首先生成图</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph = <span class="keyword">new</span> Graph(<span class="literal">true</span>); <span class="comment">// 有向图</span></span><br><span class="line">myVertices = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; myVertices.length; i++) &#123;</span><br><span class="line">    graph.addVertex(myVertices[i]);</span><br><span class="line">&#125;</span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">graph.addEdge(<span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;E&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>添加节点信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> depthFirstSearch = <span class="function"><span class="keyword">function</span> (<span class="params">v, adjList, color, find, visit, back, time</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> nabor = adjList.get(v);</span><br><span class="line">      <span class="keyword">if</span> (color[v] === <span class="string">&#x27;WHITE&#x27;</span>) &#123;</span><br><span class="line">        find[v] = ++(time.t);</span><br><span class="line">        color[v] = <span class="string">&#x27;GARY&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> vn <span class="keyword">of</span> nabor) &#123;</span><br><span class="line">          back[vn] = v;</span><br><span class="line">          depthFirstSearch(vn, adjList, color, find, visit, back, time);</span><br><span class="line">        &#125;</span><br><span class="line">        color[v] === <span class="string">&#x27;BLACK&#x27;</span></span><br><span class="line">        visit[v] = ++(time.t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">graph,</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> vertices = graph.getVertices();</span><br><span class="line">      <span class="keyword">const</span> adjList = graph.getAdjList();</span><br><span class="line">      <span class="keyword">const</span> color = &#123;&#125;;</span><br><span class="line">      <span class="keyword">const</span> find = &#123;&#125;;<span class="comment">// 发现时间</span></span><br><span class="line">      <span class="keyword">const</span> visit = &#123;&#125;;<span class="comment">// 访问时间</span></span><br><span class="line">      <span class="keyword">const</span> back = &#123;&#125;;<span class="comment">// 回溯时间</span></span><br><span class="line">      <span class="keyword">const</span> time = &#123; <span class="attr">t</span>: <span class="number">0</span> &#125;<span class="comment">//用于计时</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> vertices) &#123;</span><br><span class="line">        color[v] = <span class="string">&quot;WHITE&quot;</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        find[v] = <span class="number">0</span>;</span><br><span class="line">        visit[v] = <span class="number">0</span>;</span><br><span class="line">        back[v] = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 因为有向图，每个节点不一定能到达其他节点</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> vertices)&#123;</span><br><span class="line">        depthFirstSearch(v, adjList, color, find, visit, back, time);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        find, visit, back, time</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fn(graph)</span><br></pre></td></tr></table></figure>

<p>通过节点信息经行拓扑排序,按照访问时间从大到小</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.entries(visit).sort(<span class="function">(<span class="params">it, it2</span>) =&gt;</span> it2[<span class="number">1</span>] - it1[<span class="number">1</span>])</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/posts/ee040603/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%BE/" rel="tag">图</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/posts/9157297/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            46.全排列
          
        </div>
      </a>
    
    
      <a href="/posts/7082ffae/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">有限状态自动机</div>
      </a>
    
  </nav>

   
<!-- valine评论 -->
<div id="vcomments-box">
  <div id="vcomments"></div>
</div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<script>
  new Valine({
    el: "#vcomments",
    app_id: "lzMiGQEbMSisiam9e97mmrfD-gzGzoHsz",
    app_key: "XY8rwC62XJcP6CW9QOeNhX3z",
    path: window.location.pathname,
    avatar: "monsterid",
    placeholder: "留下你的脚印",
    recordIP: true,
  });
  const infoEle = document.querySelector("#vcomments .info");
  if (infoEle && infoEle.childNodes && infoEle.childNodes.length > 0) {
    infoEle.childNodes.forEach(function (item) {
      item.parentNode.removeChild(item);
    });
  }
</script>
<style>
  #vcomments-box {
    padding: 5px 30px;
  }

  @media screen and (max-width: 800px) {
    #vcomments-box {
      padding: 5px 0px;
    }
  }

  #vcomments-box #vcomments {
    background-color: #fff;
  }

  .v .vlist .vcard .vh {
    padding-right: 20px;
  }

  .v .vlist .vcard {
    padding-left: 10px;
  }
</style>

 
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> SunZhiqi
      </li>
    </ul>
    <ul>
      <li>
        
        
        <!--  -->
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <!-- <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a> -->
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/logo.png" alt="四月八日"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>帮到你了么朋友</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/kity.min.js"></script>


<script src="/js/kityminder.core.min.js"></script>


<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->

<!-- CanvasBackground -->


    
  </div>
</body>

</html>
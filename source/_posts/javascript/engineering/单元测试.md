---
layout: post
title: 单元测试理论
categories:
  - JavaScript
  - 工程化
tags:
  - 单元测试
  - 工程化
abbrlink: f1e8832f
date: 2020-11-23 13:43:23
---

#### TDD 测试驱动开发

+ 首先，开发者在码业务前写一些测试用例
+ 运行这些测试用例。结果肯定是运行失败，因为测试用例中的业务逻辑还没实现嘛
+ 开发者实现测试用例中的业务逻辑
+ 再运行测试用例， 如果开发者代码能力不错，这些测试用例应该可以跑通了(pass)
+ 对业务代码及时重构，包括增加注释，清理重复等。因为没人比开发者自己更了解哪些代码会对哪些部分造成影响从而导致测试失败(fail)

![](0001.png)

我们通过举例来了解一下如何实践TDD。例子中的代码可以从github上获取tdd-vs-bdd。将代码clone下来，执行命令npm install && grunt

假设我们想写一个计算阶乘的函数(这是一个很刻意的例子，但是这个例子对我们指出TDD和BDD的区别很有帮助)。TDD的常用方式是运行某函数，然后断言结果满足某个值。

在阶乘的例子中，我们使用的javascript测试框架是Mocha。废话不说，上代码：

```javascript
var assert = require('assert'),
    factorial = require('../index');
 
suite('Test', function (){
    setup(function (){
        // Create any objects that we might need
    });
 
    suite('#factorial()', function (){
        test('equals 1 for sets of zero length', function (){
            assert.equal(1, factorial(0));
        });
 
        test('equals 1 for sets of length one', function (){
            assert.equal(1, factorial(1));
        });
 
        test('equals 2 for sets of length two', function (){
            assert.equal(2, factorial(2));
        });
 
        test('equals 6 for sets of length three', function (){
            assert.equal(6, factorial(3));
        });
    });
});

```

显然上述测试会失败，因为我们尚未实现函数功能。所以接下来我们需要实现满足上述测试用例的阶乘函数。代码如下

```javascript
module.exports = function (n) {
    if (n < 0) return NaN;
    if (n === 0) return 1;
 
    return n * factorial(n - 1);

```

现在我们再次运行测试用例，所有的case都跑通了! 这就是TDD的使用方式。

#### BDD 行为驱动开发

BDD旨在消除TDD过程中可能造成的问题。

与TDD相比，BDD是通过编写行为和规范来驱动软件开发。 行为和规范可能看起来与测试非常相似，但是它们之间却有着微妙但重要的区别。

```javascript
var assert = require('assert'),
    factorial = require('../index');
 
describe('Test', function (){
    before(function(){
        // Stuff to do before the tests, like imports, what not
    });
 
    describe('#factorial()', function (){
        it('should return 1 when given 0', function (){
            factorial(0).should.equal(1);
        });
 
        it('should return 1 when given 1', function (){
            factorial(1).should.equal(1);
        });
 
        it('should return 2 when given 2', function (){
            factorial(2).should.equal(2);
        });
 
        it('should return 6 when given 3', function (){
            factorial(3).should.equal(6);
        });
    });
 
    after(function () {
        // Anything after the tests have finished
    });
});
```

#### 敏捷开发

敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。
---
title: 图
mathjax: true
tags:
  - 算法
  - 数据结构
  - 图
categories:
  - 算法
  - 数据结构
abbrlink: ee040603
date: 2020-10-15 12:25:44
---

#### 图的相关术语

图是网络结构的抽象模型。是一组由**边**连接的**节点**（或顶点）

任何二元关系都可以用图来表示。

数学上表示为 {%mathjax%}G = (V, E){%endmathjax%},{%mathjax%}V{%endmathjax%} 表示一组顶点，{%mathjax%}E{%endmathjax%} 表示一组边，连接{%mathjax%}V{%endmathjax%}中的顶点

![](0001.png)

#### 相关概念

+ 由一条边连接在一起的顶点称为**相邻顶点**。比如，A 和B 是相邻的，A 和D 是相邻的，A 和C 是相邻的，A 和E 不是相邻的。

+ 一个顶点的**度**是其相邻顶点的数量。比如，A 和其他三个顶点相连接，因此A 的度为3；E和其他两个顶点相连，因此E 的度为2。

+ **路径**是顶点v1, v2, …, vk 的一个连续序列，其中vi 和vi+1 是相邻的。以上一示意图中的图为例，其中包含路径A B E I 和A C D G。

+ 简单路径要求不包含重复的顶点。举个例子，A D G 是一条简单路径。除去最后一个顶点（因为它和第一个顶点是同一个顶点），**环**也是一个简单路径，比如A D C A（最后一个顶点重新回到A）

+ 如果图中不存在环，则称该图是**无环的**。如果图中每两个顶点间都存在路径，则该图是**连通的**。

#### 有向图 无向图

图可以是无向的（边没有方向）或是有向的（有向图）。第一张图是无向图，下面这张是又向图

![](0002.png)

如果图中每两个顶点间在**双向上**都存在路径，则该图是强连通的。例如，C 和D 是强连通的，而A 和B 不是强连通的。

图还可以是未加权的（目前为止我们看到的图都是未加权的）或是加权的。如下图所示，加权图的边被赋予了权值。

#### 应用

+ 搜索图中的一个特定顶点或搜索一条特定边

+ 寻找图中的一条路径（从一个顶点到另一个顶点

+ 寻找两个顶点之间的最短路径，以及环检测。


### 图的表示

#### 邻接矩阵

每个节点都和一个整数相关联，该整数将作为数组的索引。我们用一个二维数组来表示顶点之间的连接。

如果索引为`i` 的节点和索引为 `j` 的节点相邻，则 `array[i][j] === 1`，否则`array[i][j]` === 0，如下图所示。

![](0004.png)

由于不是强连通图（每两个节点间都存在路径），所以数组中有大量的0

给定顶点的相邻顶点，即使该顶点只有一个相邻顶点，我们也不得不迭代一整行。

邻接矩阵表示法不够好的另一个理由是，图中顶点的数量可能会改变，修改二维数组不够灵活。

#### 邻接表

邻接表由图中每个顶点的相邻顶点列表所组成。

存在好几种方式来表示这种数据结构。我们可以用列表（数组）、链表，甚至是散列表或是字典来表示相邻顶点列表。

![](0005.png)

对大多数问题来说都是更好的选择

但要找出顶点 v 和 w 是否相邻，使用邻接矩阵会比较快

#### 关联矩阵

关联矩阵中，矩阵的行表示顶点，列表示边。如下图所示，

使用二维数组来表示两者之间的连通性，如果顶点 `v` 是边 `e` 的入射点，则 `array[v][e] === 1`

否则，`array[v][e] === 0`

![](0006.png)

关联矩阵通常用于边的数量比顶点多的情况，以节省空间和内存。

### 创建Graph 类

#### 类的结构

+ 图是否有向，默认无无向图 ①

+ 使用一个数组来储存顶点的名字 ②

+ 使用一个字典来储存邻接表，字典将会使用顶点的名字作为键，邻接顶点列表作为值 ③

```javascript
class Graph {
  constructor(isDirected = false) {
    this.isDirected = isDirected; // ①
    this.vertices = []; // ②
    this.adjList = new Map(); // ③
  }
}
```

#### 插入顶点方法

+ 如果顶点不存 ④ 在顶点列表中添加节点 ⑤ 
 
+ 在邻接表中为该顶点创建空数组 ⑥

```javascript
addVertex(v) {
  if (!this.vertices.has(v)) { // ④
    this.vertices.push(v); // ⑤ 
    this.adjList.add(v, []); // ⑥
  }
}
```

#### 建立链接方法

+ 如果建立链接的两个点不在顶点列表中，要先填入顶点列表

+ 将 `w` 加入到 `v` 的邻接表中，表示添加了一条自顶点 `v` 到顶点 `w` 的边

+ 无向图需要添加一条自 `w` 到 `v` 的边

```javascript
addEdge(v, w) {
  if (!this.adjList.has(v)) {
    this.addVertex(v);
  }
  if (!this.adjList.has(w)) {
    this.addVertex(w);
  }
  this.adjList.get(v).push(w);
  if (!this.isDirected) {
    this.adjList.get(w).push(v);
  }
}
```
> 请注意我们只是往数组里新增元素，因为数组已经在行 ⑥ 被初始化了

#### 取值

一个返回顶点列表，另一个返回邻接表

```javascript
getVertices() {
  return this.vertices;
}
getAdjList() {
  return this.adjList;
}
```

#### 测试

```javascript
class Graph {
  constructor(isDirected = false) {
    this.isDirected = isDirected; // {1}
    this.vertices = []; // {2}
    this.adjList = new Map(); // {3}
  }
  addVertex(v) {
    if (!this.vertices.includes(v)) { // {5}
      this.vertices.push(v); // {6}
      this.adjList.set(v, []); // {7}
    }
  }
  addEdge(v, w) {
    if (!this.adjList.has(v)) {
      this.addVertex(v);
    }
    if (!this.adjList.has(w)) {
      this.addVertex(w);
    }
    this.adjList.get(v).push(w);
    if (!this.isDirected) {
      this.adjList.get(w).push(v);
    }
  }
  getVertices() {
    return this.vertices;
  }
  getAdjList() {
    return this.adjList;
  }
  toString() {
    let s = '';
    for (let i = 0; i < this.vertices.length; i++) { // {15}
      s += `${this.vertices[i]} -> `;
      const neighbors = this.adjList.get(this.vertices[i]); // {16}
      for (let j = 0; j < neighbors.length; j++) { // {17}
        s += `${neighbors[j]} `;
      }
      s += '\n'; // {18}
    }
    return s;
  }
}
const graph = new Graph();
const myVertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']; // {12}
for (let i = 0; i < myVertices.length; i++) { // {13}
  graph.addVertex(myVertices[i]);
}
graph.addEdge('A', 'B'); // {14}

graph.addEdge('A', 'C');
graph.addEdge('A', 'D');
graph.addEdge('C', 'D');
graph.addEdge('C', 'G');
graph.addEdge('D', 'G');
graph.addEdge('D', 'H');
graph.addEdge('B', 'E');
graph.addEdge('B', 'F');
graph.addEdge('E', 'I');

console.log(graph.toString());
```

### 图的遍历

有两种算法可以对图进行遍历：**广度优先搜索（breadth-first search，BFS）** 和 **深度优先搜索（depth-first search，DFS）**

图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通，检查图是否含有环，等等。

图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。

完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。

为了保证算法的效率，务必访问每个顶点至多两次。连通图中每条边和顶点都会被访问到。

广度优先搜索算法和深度优先搜索算法基本上是相同的，只有一点不同，那就是待访问顶点列表的数据结构，如下表所示。
---
title: 排序数组查找
mathjax: true
abbrlink: e263ab5
date: 2020-10-09 13:36:23
tags:
  - JavaScript
  - 算法
categories:
  - 每日一题
---

统计一个数字在排序好的数组中出现的位置

### 循环

```javascript
var find = function (arr, target) {
    var i = 0,
        len = arr.length,
        count = 0;
    for (; i < len; i++) {
        if (arr[i] === target) {
            count++;
        }
    }
    return count;
}
```

因为式排序数组所以找到后可以跳出

```javascript
var find = function (arr, target) {
    var start,
        i,
        len = arr.length;
    for (i = 0; i < len; i++) {
        if (arr[i] === target && start === undefined) {
            start = i;
        } else if (arr[i] !== target && start !== undefined) {
            return i - start;
        }
    }
    return 0;
}
```

**复杂度分析**

+ 时间复杂度：{% mathjax %}O(n){% endmathjax %}

+ 空间复杂度：{% mathjax %}O(1){% endmathjax %}

### 二分法

查找一个数字的方法

```javascript
function find(arr, target) {
    var left = 0,
        right = arr.length - 1,
        middle = Math.floor((right - left) / 2);
    while (left <= right) {
        if (arr[middle] === target) {
            return middle
        } else if (arr[middle] < target) {
            left = middle + 1;
        } else {
            right = middle - 1
        }
        middle = Math.floor((left + right) / 2)
    }
    return -1;
}
```

递归方式查找一个数字

```javascript
function find(left, right, arr, target) {
    if (left > right) return -1;
    var middle = Math.floor((right + left) / 2);
    console.log(left,right,arr,target,middle)

    if (arr[middle] === target) {
        return middle;
    } else if (arr[middle] < target) {
        return find(middle + 1, right, arr, target)
    } else {
        return find(left, middle - 1, arr, target)
    }
}
```

这道题可以尝试找到第一个和最后一个目标值的位置


```javascript
function find(arr, target) {
    if (arr.length === 0) return -1;
    var left = 0,
        right = arr.length;
    var leftIndex = findleft(left, right, arr, target)
    var lastIndex = findright(left, right, arr, target)
    if (leftIndex !== -1 && lastIndex !== -1) {
        return lastIndex - leftIndex + 1;
    }
    return -1;
}

function findleft(left, right, arr, target) {
    while (left <= right) {
        var middle = middle = Math.floor((left + right) / 2);
        if (arr[middle] === target) {
            if (arr[middle - 1] !== target) {
                return middle
            } else {
                right = middle - 1;
            }
        } else if (arr[middle] > target) {
            right = middle - 1;
        } else if (arr[middle] < target) {
            left = middle + 1;
        }
    }
    return -1;
}

function findright(left, right, arr, target) {
    while (left <= right) {
        var middle = middle = Math.floor((left + right) / 2);
        if (arr[middle] === target) {
            if (arr[middle + 1] !== target) {
                return middle
            } else {
                left = middle + 1;
            }
        } else if (arr[middle] > target) {
            right = middle - 1;
        } else if (arr[middle] < target) {
            left = middle + 1;
        }
    }
    return -1;
}
```
递归的方式

```javascript
function find(arr, target) {
    if (arr.length === 0) return -1;
    var left = 0,
        right = arr.length;
    var leftIndex = findleft(left, right, arr, target)
    var lastIndex = findright(left, right, arr, target)
    if (leftIndex !== -1 && lastIndex !== -1) {
        return lastIndex - leftIndex + 1;
    }
    return -1;
}

function findleft(left, right, arr, target) {
    if (left > right) return -1;
    var middle = Math.floor((right + left) / 2);
    if (arr[middle] === target) {
        if (arr[middle - 1] !== target) {
            return middle
        } else {
            return findleft(left, middle - 1, arr, target)
        }
    } else if (arr[middle] < target) {
        return findleft(middle + 1, right, arr, target)
    } else {
        return findleft(left, middle - 1, arr, target)
    }
}

function findright(left, right, arr, target) {
    if (left > right) return -1;
    var middle = Math.floor((right + left) / 2);
    if (arr[middle] === target) {
        if (arr[middle + 1] !== target) {
            return middle
        } else {
            return findright(middle + 1, right, arr, target)
        }
    } else if (arr[middle] < target) {
        return findright(middle + 1, right, arr, target)
    } else {
        return findright(left, middle - 1, arr, target)
    }
}
```

**复杂度分析**

+ 时间复杂度：{% mathjax %}O(log_2n){% endmathjax %}

+ 空间复杂度：{% mathjax %}O(1){% endmathjax %}
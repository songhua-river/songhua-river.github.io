---
title: 隐式类型转换，下面代码的执行结果是什么？
tags:
  - 类型转换
  - JavaScript
categories:
  - 每日一题
abbrlink: d8942393
date: 2020-09-10 09:32:42
---

```javaScript
    let a = [];
    let b = "0";
    console.log(a == 0);
    console.log(a == !a);
    console.log(b == 0);
    console.log(a == b);
```

#### 答案

```javaScript
    let a = [];
    let b = "0";
    console.log(a == 0); //true
    console.log(a == !a);//true
    console.log(b == 0);//true
    console.log(a == b);//false
```

#### 解析

###### [] == 0 => true

引用类型和原始类型比较，按照ToPromitive规则，对象类型会尝试转换成原始类型的值，在进行比较

① []==0 => [].valueOf().toString() == 0 => "" == 0

数组是引用类型，所以会进行ToPrimitive操作，即调用valueOf尝试转为原始值，因为[].valueOf() 返回**数组引用**并不是一个原始类型值，所以再次调用toString()方法，数字被转为空字符串 ""

② "" == 0 => Number("") == 0 => true

空字符串和数字的比较是原始类型值的比较，原始类型值会转为数字在比较，结果为true

###### [] == ![] => true

!运算的优先级高于==运算，所以先执行!运算把[]转为false
> null undefined NaN 空字符串 1 false,取反都为true

[] == false 如果有一个操作数是Boolean类型，在比较之前先将其转为数字，[]==0 结果同第一问为 true

###### "0" == 0 => true

原始类型值的比较会转为数值在比较 Number(“0“) == 0 => true

###### [] == “0“ => false

由第一问可知，[]转为原始类型， 所以比较 "" == “0“，结果为flase
---
title: 词法分析
mathjax: true
abbrlink: 54df2ad9
date: 2020-10-14 19:07:32
categories:
- 编译原理
tags:
- 编译原理
---

#### 此法分析流程

```flow
op1=>operation: 源程序
op2=>operation: 词法分析器
（字符流）
op3=>operation: 记号
对字符流切分，变为记号流）
op4=>operation: 语法分析器
op5=>operation: 抽象语法树
op6=>operation: 语义分析器
op7=>operation: 中间表示
op1->op2(right)->op3->op4->op5(right)->op6->op7(right)

```

字符流为一段文本，注意在windows下每行的末尾是一个换行符和一个回车符 `\r\n`, 在linux下只有一个回车符`\n`

在字符流的末尾会有一个EOF标识，为Scii码不能编码的为-1

```txt
if (x > 5) {
    y = true;
}
```

通过词法分析，把字符流切分成单词,其中的空格被舍去

```txt
IF LPAREN IDENT(x) GT INT(5) RPAREN LPAREN
    IDENT(y) ASSIGN BOOLEN(true) SEMICOLON
RPAREN EOF
```

核心在于记号的数据结构的定义和字符流到记号流转换的算法

#### 记号的数据结构定义

通过一个有限数字来定义所有可能遇到的记号，包括 关键字，括号等

```javascript
let kind = ['IF',"LPAREN","ID","INTLIT",...];
```

**记号描述对象**

```javascript
let token = {
    kind: "IF",
    // lexeme标识当前记号的单词
    // 因为if与标识唯一对应，所以不需要写
    lexeme:0
}
let token = {
    kind: 'ID',
    lexeme :'x'
}
```

#### 词法分析器的任务

字符流到记号流

+ 字符流：和被编译的语言密切相关 （ASCII,Unicode,or...）

+ 记号流：编译器内部定义的数据结构，编码所识别出的词法单元

#### 词法分析器实现-手工编码

相对复杂，容易出错，是目前主流的实现方法

转移

![](0002.png) 

```javascript
function token(char){
    let index= 0;
    const c = char[index];
    if(c==='<'){
        c = char[index++];
        if(c==='='){
            return "LE";
        }else{
            // 如果是其他字符
            // 说明下一个字符并不是集合中的一种可能
            // 所以需要回滚放回到解析队列中，并返回结果
            rollback();
            return "LT"
        }
    }else if(c==='='){
        c = char[index++];
        if(c==='='){
            c = char[index++];
            if(c==='='){
                //全等
                return "FEQ"
            }else{
                rollback();
                return "EQ"
            }
        }else{
            // 赋值
            rollback();
            return 'ASSIGNMENT'
        }
    }else if(c==='>'){
        //与小于号类似
    }
}
```
#### 标识符和关键字

很多语言的标识符和关键字是有交集的

标识符（变量）以字母下划线开头，后面可以是多个数字，字母下划线

通过转移表分析标识符

```javascript
function token(char) {
    let index = 0;
    let c = char[index];
    if (/[a-zA-Z_]/.text(c)) {
        c = char[index++];
        while (/[a-zA-Z0-9_]/.test(c)) {
            c = char[index];
        }
        rollback();
        return 'ID';
    }else{
        return false;
    }
}
```

关键字 `if`,`class`,等也满足标识符的规则

#### 通过修改转移表区分关键字


如果在转移过程与遇到有关键字的情况，把关键字单独处理

```javascript
function token(char) {
    let index = 0;
    let c = char[index];
    if (/[a-hj-zA-Z_]/.text(c)) {
        c = char[index++];
        if (/[a-zA-Z0-9_]/.test(c)) {
            while (/[a-zA-Z0-9_]/.test(c)) {
                c = char[index];
            }
            return 'IDENT';
        } else {
            rollback();
            return 'ID';
        }
    } else if (c === 'i') {
        c = char[index++];
        if (c === 'f') {
            c = char[index++];
            if (/[a-zA-Z0-9_]/.test(c)) {
                while (/[a-zA-Z0-9_]/.test(c)) {
                    c = char[index];
                }
                return 'IDENT';
            } else {
                rollback();
                return 'IF';
            }
        }

    } else {
        return false;
    }
}
```

#### 通过哈希表区分关键字

对所有的标识符和关键字统一按照标识符的转移表进行识别

识别完成后进一步看是否是关键字

通过构建哈希表（完美哈希），实现 {% mathjax %}O(1){% endmathjax %} 时间复杂度 
<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
<link rel="stylesheet" href="/css/remixicon.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  
<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "https://hm.baidu.com/hm.js?e6048c3e856b5cbdb1e6ef6e00d5b63d";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <div class="bg-box-wrapper">
        <img src="/images/cover-blur.jpg" data-uhd-src="/images/cover-uhd.jpg" alt="image frame" class="cover-progressive-img" id="cover-img"/>
      </div>
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">四月八日</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['最轻的并不是一根羽毛，而是一双飞鸟的翅膀', '愿你足够强大，也要足够温柔', ''],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <article class="articles">
    
    
    
    
    <article
  id="post-node/nginx"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/a477be03/"
    >nginx</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/a477be03/" class="article-date">
  <time datetime="2021-01-12T15:46:25.000Z" itemprop="datePublished">2021-01-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Node/">Node</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="正向-反向代理"><a href="#正向-反向代理" class="headerlink" title="正向/反向代理"></a>正向/反向代理</h4><p>正向代理: 当自己的电脑A需要访问B网站时，如果访问不了，通过一台中间服务器取访问B，在把返回的结果返回给A，特点就是明确的知道想要访问的网站</p>
<p>反向代理： 我们的A电脑需要访问集群中的资源，代理服务器帮助我们返回资源但是不知道访问的是哪台服务器的资源，这种方式称为反向代理.</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>通过Nginx服务器寻找压力最小的服务器经行访问</p>
<h4 id="Upstream-模块"><a href="#Upstream-模块" class="headerlink" title="Upstream 模块"></a>Upstream 模块</h4><p>ip_hash 保证用户的多次访问被分发到同一台服务器</p>
<p>server 指定某台服务器的权重</p>
<h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su root</span><br><span class="line">apt-get install nginx</span><br></pre></td></tr></table></figure>

<p>启动 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx start</span><br></pre></td></tr></table></figure>

<p>nginx文件安装完成之后的文件位置：</p>
<p>/usr/sbin/nginx：主程序<br>/etc/nginx：存放配置文件<br>/usr/share/nginx：存放静态文件<br>/var/log/nginx：存放日志</p>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必填，表示连接数</span></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">  upstream firsttest&#123;</span><br><span class="line">    server xxx.xxx.xx;</span><br><span class="line">  &#125;</span><br><span class="line">  server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass http://firsttest</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nginx/" rel="tag">Nginx</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-node/线上部署"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/5cd50760/"
    >线上部署</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/5cd50760/" class="article-date">
  <time datetime="2021-01-12T15:44:35.000Z" itemprop="datePublished">2021-01-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Node/">Node</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node/" rel="tag">Node</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-javascript/used/koa"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/264a155d/"
    >Koa Router</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/264a155d/" class="article-date">
  <time datetime="2021-01-12T14:47:14.000Z" itemprop="datePublished">2021-01-12</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/">应用案例</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>中间件容器 负责不同组件和不同服务之间的交互，需要一个中间件负责统一的对服务使用</p>
<p>一个简单的中间件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m2 = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> m3 = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">  .use(m1)</span><br><span class="line">  .use(m2)</span><br><span class="line">  .use(m3)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p>最终返回的结果为 1 3 5 2 4 6</p>
<p>也就是洋葱模型，由<code>koa-compose</code>模块来实现</p>
<p>实现洋葱模型的几个关键：</p>
<ul>
<li>统一的上下文 ctx</li>
<li>操作先进后出 通过<code>next</code>控制</li>
<li>有提前结束的机制</li>
</ul>
<p><strong>中间件类型</strong></p>
<ul>
<li>应用级中间件 vue全局导航守卫</li>
<li>路由级中间件 独享路由守卫</li>
<li>错误处理中间件  </li>
<li>第三方中间件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> m1 = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 应用级中间件最先被访问</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;应用级中间件&#x27;</span>);</span><br><span class="line">  <span class="comment">//通过next进入路由级中间件</span></span><br><span class="line">  <span class="keyword">await</span> next();</span><br><span class="line">  <span class="keyword">if</span> (ctx.status == <span class="number">404</span>) &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;404&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 路由级中间件会按照顺序访问</span></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;路由级中间件1&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;路由级中间件2&#x27;</span>);</span><br><span class="line">  ctx.body = <span class="string">&#x27;路由&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes());</span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">  .use(m1)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<h4 id="koa-和-express-比较"><a href="#koa-和-express-比较" class="headerlink" title="koa 和 express 比较"></a>koa 和 express 比较</h4><p>express 通过connect添加中间件 封装了路由，视图, 异步处理使用callback (深层次的错误不能捕获)</p>
<p>koa 依赖于co模块，不包含任何中间件， 处理了回调 (使用了async await) 和错误处理(使用了try catch),</p>
<h4 id="处理get-post-请求参数"><a href="#处理get-post-请求参数" class="headerlink" title="处理get post 请求参数"></a>处理get post 请求参数</h4><p><a target="_blank" rel="noopener" href="https://github.com/dlau/koa-body#readme">koa-body</a></p>
<h4 id="静态资源中间件"><a href="#静态资源中间件" class="headerlink" title="静态资源中间件"></a>静态资源中间件</h4><p><a target="_blank" rel="noopener" href="https://github.com/koajs/static#readme">koa-static</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Koa/" rel="tag">Koa</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-node/文件系统"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/1b9c8662/"
    >文件系统</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/1b9c8662/" class="article-date">
  <time datetime="2021-01-09T11:13:33.000Z" itemprop="datePublished">2021-01-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Node/">Node</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>文件描述符 </p>
<p>在 POSIX （可移植操作系统）系统上，对于每个进程，内核都维护着一张当前打开着的文件和资源的表格。 每个打开的文件都分配了一个称为文件描述符的简单的数字标识符。 在系统层，所有文件系统操作都使用这些文件描述符来标识和跟踪每个特定的文件。 Windows 系统使用了一个虽然不同但概念上类似的机制来跟踪资源。 为了简化用户的工作，Node.js 抽象出操作系统之间的特定差异，并为所有打开的文件分配一个数字型的文件描述符。</p>
<p>fs.open() 方法用于分配新的文件描述符。 一旦被分配，则文件描述符可用于从文件读取数据、向文件写入数据、或请求关于文件的信息。</p>
<p>大多数操作系统限制在任何给定时间内可能打开的文件描述符的数量，<strong>因此当操作完成时关闭描述符至关重要。 如果不这样做将导致内存泄漏，最终导致应用程序崩溃。</strong></p>
<p>r+ 打开文件用于读写。<br>w+ 打开文件用于读写，将流定位到文件的开头。如果文件不存在则创建文件。<br>a 打开文件用于写入，将流定位到文件的末尾。如果文件不存在则创建文件。<br>a+ 打开文件用于读写，将流定位到文件的末尾。如果文件不存在则创建文件。</p>
<h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node/" rel="tag">Node</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-node/stream模块"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/4a21a07/"
    >stream模块</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/4a21a07/" class="article-date">
  <time datetime="2021-01-07T10:53:23.000Z" itemprop="datePublished">2021-01-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Node/">Node</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>流有起点和终点，逐端读取文件,大文件</p>
<p>为什么要使用？</p>
<p>可以逐渐读取，内存效率</p>
<p>把大的文件拆分成一块一块，时间效率</p>
<p>一个简单的读写留的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//创建读取数据流 </span></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">&#x27;./yarn.lock&#x27;</span>)</span><br><span class="line"><span class="comment">//创建写入数据流 </span></span><br><span class="line"><span class="keyword">const</span> ws = fs.createWriteStream(<span class="string">&#x27;./yarn.copy.lock&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">  ws.write(chunk)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ws.end()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用这种方法不能保证读写一直，所以需要使用pipe</p>
<p>注意只有可读流才有pipe方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="comment">//创建读取数据流 </span></span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">&#x27;./yarn.lock&#x27;</span>)</span><br><span class="line"><span class="comment">//创建写入数据流 </span></span><br><span class="line"><span class="keyword">const</span> ws = fs.createWriteStream(<span class="string">&#x27;./yarn.copy.lock&#x27;</span>)</span><br><span class="line">rs.pipe(ws)</span><br></pre></td></tr></table></figure>

<h4 id="流的类型"><a href="#流的类型" class="headerlink" title="流的类型"></a>流的类型</h4><ul>
<li>可读流</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(<span class="string">&#x27;./yarn.lock&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">//设置编码方式</span></span><br><span class="line">  encoding: <span class="string">&#x27;utf8&#x27;</span>,</span><br><span class="line">  <span class="comment">//设置缓冲区大小,六个字节</span></span><br><span class="line">  highWaterMark: <span class="number">6</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chunk)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>两种调用方式，自动调用(flowing)还是手动调用(pause)</p>
<p>使用<code>stream.on(&quot;data&quot;,()=&gt;&#123;&#125;)</code> 为自动模式，读取的时候会不断触发 <code>data</code> 方法,resume pipe 都是自动模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rs.on(<span class="string">&#x27;readable&#x27;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(chunk)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//手动读取数据</span></span><br><span class="line">rs.read()</span><br></pre></td></tr></table></figure>

<ul>
<li>可写流</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ws = fs.createWriteStream(<span class="string">&#x27;a.txt&#x27;</span>)</span><br><span class="line">ws.write(<span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">&#x27;finish&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ws.end()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Duplex: 双工流  net.socket</p>
</li>
<li><p>transform: 转换流 文件压缩</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件模块</span></span><br><span class="line"><span class="keyword">const</span> stream = <span class="built_in">require</span>(<span class="string">&#x27;stream&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> transform = stream.Transform(&#123;</span><br><span class="line">  <span class="comment">//自定义转换方法</span></span><br><span class="line">  <span class="function"><span class="title">transform</span>(<span class="params">chunk, encoding, cb</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//大小写转换，放到缓冲区</span></span><br><span class="line">    <span class="built_in">this</span>.push(chunk.toString().toLowerCase())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">transform.write(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(transform.read().toString());</span><br></pre></td></tr></table></figure>

<p>stream对象都是EventEmitter的实例，所以可以发布事件</p>
<ul>
<li>流的链式操作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> zlib = <span class="built_in">require</span>(<span class="string">&#x27;zlib&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.createReadStream(<span class="string">&#x27;a.txt&#x27;</span>)</span><br><span class="line">  .pipe(zlib.createGunzip)</span><br><span class="line">  .pipe(fs.createWriteStream(<span class="string">&#x27;a.zip&#x27;</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>使用readline逐行读取</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&#x27;readline&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> filePath = path.resolve(__dirname,<span class="string">&#x27;./yarn.lock&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> rs = fs.createReadStream(filePath);</span><br><span class="line"><span class="keyword">const</span> rl = readline.createInterface(&#123;</span><br><span class="line">  input:rs</span><br><span class="line">&#125;)</span><br><span class="line">rl.on(<span class="string">&#x27;line&#x27;</span>,<span class="function">(<span class="params">l</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(l)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node/" rel="tag">Node</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-node/事件驱动"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/639e9d87/"
    >事件驱动</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/639e9d87/" class="article-date">
  <time datetime="2021-01-06T12:25:34.000Z" itemprop="datePublished">2021-01-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Node/">Node</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="event简单使用"><a href="#event简单使用" class="headerlink" title="event简单使用"></a>event简单使用</h4><p>引入event模块，并创建事件对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.eventEmitter();</span><br></pre></td></tr></table></figure>

<p>绑定事件处理函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> connctHandler = <span class="function"><span class="keyword">function</span> <span class="title">connected</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;connected&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eventEmitter.on(<span class="string">&#x27;connection&#x27;</span>,connctHandler)</span><br></pre></td></tr></table></figure>

<p>触发事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventEmitter.emit(<span class="string">&#x27;connection&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="EventEmitter-与-发布-订阅模式的关系"><a href="#EventEmitter-与-发布-订阅模式的关系" class="headerlink" title="EventEmitter 与 发布/订阅模式的关系"></a>EventEmitter 与 发布/订阅模式的关系</h4><p>Node.js 中的 EventEmitter 模块就是用了发布/订阅这种设计模式，发布/订阅 模式在主体与观察者之间引入消息调度中心，主体和观察者之间完全透明，所  有的消息传递过程都通过消息调度中心完成，也就是说具体的业务逻辑代码将会是在消息调度中心内完成。</p>
<ul>
<li>once 方法的实现</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EventEmitter.prototype.once = <span class="function"><span class="keyword">function</span> (<span class="params">type, listener</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中间函数，在调用完之后立即删除订阅</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">only</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        listener();</span><br><span class="line">        _this.removeListener(type, only);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//origin保存原回调的引用，用于remove时的判断</span></span><br><span class="line">    only.origin = listener;</span><br><span class="line">    <span class="built_in">this</span>.on(type, only);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件循环中的事件是什么情况下产生的？什么情况下触发的？</li>
</ul>
<p>Node.js 中所有所有异步 I/O 操作在完成时都会发送一个事件到事件队列</p>
<p>Node.js 中许多对象都会分发事件： 一个net.Server 对象会在每次有新连接时触发一个事件，fs.readStream对象会在文件被打开的时候触发一个事件，所有这些产生事件的对象都是events.EventEmitter的实例</p>
<p>！<a href="0001.png"></a></p>
<p>关于事件你看图中第三部分，事件循环那里。Node.js 所有的异步 I/O 操作(net.Server， fs.readStream 等)在完成后都会添加一个事件到事件循环的事件队列中。</p>
<p>事件的触发，我们只需要关注图中第三部分，事件循环会在事件队列中取出事件处理。fs.open产生事件的对象都是 events.EventEmitter 的实例，继承了EventEmitter，从事件循环取出事件的时候，触发这个事件和回调函数。</p>
<ul>
<li>事件类型为error的问题</li>
</ul>
<p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p>
<p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。</p>
<ul>
<li><p>可以通过process.on(‘warning’)来获得更具体的信息（emitter、event、eventCount）</p>
</li>
<li><p>打印warn详细内容</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">&#x27;warning&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="EventEmitter的应用场景"><a href="#EventEmitter的应用场景" class="headerlink" title="EventEmitter的应用场景"></a>EventEmitter的应用场景</h4><p>不能try/catch的错误异常抛出可以使用它</p>
<p>好多常用模块继承自EventEmitter 比如fs模块 net模块</p>
<h4 id="发布-订阅模式与观察者模式"><a href="#发布-订阅模式与观察者模式" class="headerlink" title="发布/订阅模式与观察者模式"></a>发布/订阅模式与观察者模式</h4><p><img src="/posts/639e9d87/0002.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node/" rel="tag">Node</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-node/node环境和npm"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/1128db1b/"
    >node和npm</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/1128db1b/" class="article-date">
  <time datetime="2021-01-06T12:05:53.000Z" itemprop="datePublished">2021-01-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Node/">Node</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="REPL-交互式显示"><a href="#REPL-交互式显示" class="headerlink" title="REPL 交互式显示"></a>REPL 交互式显示</h4><p>在命令行工具中输入node,进入交互式环境</p>
<ul>
<li>linux ctrl+d 退出</li>
<li>tab 键补全</li>
<li>.help 查看帮助</li>
</ul>
<h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h4><p>升级npm <code>npm install -g npm</code></p>
<p>查询可安装的包 <code>npm serch xxx</code> </p>
<h4 id="node模块化"><a href="#node模块化" class="headerlink" title="node模块化"></a>node模块化</h4><p>文件和模块是一一对应的，一个node文件就是一个模块</p>
<p>这个文件可能是JavaScript代码，JSON或者编译过的c/c++ 扩展</p>
<p>Node.js 中存在4类模块（原生模块和3种文件模块）</p>
<p><strong>builtin module</strong>: Node中以c++形式提供的模块，如tcp_wrap、contextify等</p>
<p><strong>constants module</strong>: Node中定义常量的模块，用来导出如signal, openssl库、文件访问权限等常量的定义。如文件访问权限中的O_RDONLY，O_CREAT、signal中的SIGHUP，SIGINT等。</p>
<p><strong>native module</strong>: Node中以JavaScript形式提供的模块，如http,https,fs等。有些native module需要借助于builtin module实现背后的功能。如对于native模块buffer ,还是需要借助builtin node_buffer.cc中提供的功能来实现大容量内存申请和管理，目的是能够脱离V8内存大小使用限制。</p>
<p><strong>3rd-party module</strong>: 以上模块可以统称Node内建模块，除此之外为第三方模块，典型的如express模块。</p>
<ul>
<li>module.exports和exports的区别</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> circle = <span class="built_in">require</span>(<span class="string">&#x27;./circle.js&#x27;</span>);  </span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&#x27;The area of a circle of radius 4 is &#x27;</span> + circle.area(<span class="number">4</span>)); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> PI = <span class="built_in">Math</span>.PI;  </span><br><span class="line"><span class="built_in">exports</span>.area = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> PI * r * r;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<p>如果你的模块属于“模块实例（module instances）”，就像官方文档中给出的示例那样，那么exports足以满足要求。</p>
<p>但是事实上，require()返回的是module.exports，exports只是module.exports的一个引用，exports的作用只在module.exports没有指定的时候，收集属性并附加到module.exports。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="string">&#x27;孙悟空&#x27;</span>;  </span><br><span class="line"><span class="built_in">exports</span>.name = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我是白骨精&#x27;</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个模块会完全忽略exports.name，因为module.exports被指定了另一个对象。你的模块不一定是模块实例（module instances），你的模块可以是任意的，你设置成module.exports的Javascript对象。如果你不显示的指定module.exports，那么返回的将是exports和exports附加的值。</p>
<p>也可以这样认为，一个模块刚开始的时候，module.exports和exports是一样的，exports只是module.exports的一个别名，两者都是{}。</p>
<p>当你给module.exports指定一个对象的时候，两者就不再一样的，而模块导出的一定是module.exports。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node/" rel="tag">Node</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-javascript/used/性能优化基础"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/5527b4f7/"
    >性能优化基础</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/5527b4f7/" class="article-date">
  <time datetime="2020-12-27T09:59:35.000Z" itemprop="datePublished">2020-12-27</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/">应用案例</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="Navigation-Timing"><a href="#Navigation-Timing" class="headerlink" title="Navigation Timing"></a><a target="_blank" rel="noopener" href="https://www.w3.org/TR/2012/REC-navigation-timing-20121217/">Navigation Timing</a></h4><p><img src="/posts/5527b4f7/0001.png"></p>
<ul>
<li>prompt for unload </li>
</ul>
<p>为卸载页面作准备， 释放js资源</p>
<ul>
<li>DNS domainLookupStart domainLookupEnd</li>
</ul>
<p>DNS 服务器会影响解析时间，DNS基于UDP协议</p>
<p>DNS （Domain Name System) 域名系统，用于将域名转换为IP</p>
<p>顶级域名: .com .org .club</p>
<p>域名资源记录： 域名服务商的配置记录 （3A，4A）</p>
<p>域名解析流程： </p>
<ul>
<li>TCP </li>
</ul>
<p>可能会产生ssl的握手（secureConnetionStart），需要放在nigix上处理</p>
<p>服务器的连接数会影响响应的速度，也受到物理距离的影响</p>
<ul>
<li>request response</li>
</ul>
<p>请求开始到响应开始包括，数据传输时间，服务器处理时间，服务器请求时间，服务器渲染时间</p>
<p>服务端优化： 服务端缓存，sql查询时间，服务端渲染，生成数据大小（使用压缩）</p>
<h4 id="三次握手四次挥手"><a href="#三次握手四次挥手" class="headerlink" title="三次握手四次挥手"></a>三次握手四次挥手</h4><p><img src="/posts/5527b4f7/0001.jpeg"></p>
<p>序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号。</p>
<p>确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</p>
<p>确认ACK：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效</p>
<p>同步SYN：连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。</p>
<p>终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接</p>
<p>PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号。</p>
<p><img src="/posts/5527b4f7/0002.png"></p>
<p>第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p>！<a href="0003.png"></a></p>
<p>1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</p>
<p>2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
<p>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</p>
<p>4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p>
<p>5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p>
<p>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<ul>
<li>为什么连接的时候是三次握手，关闭的时候却是四次握手？</li>
</ul>
<p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<ul>
<li>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</li>
</ul>
<p>有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
<ul>
<li>为什么不能用两次握手进行连接？ </li>
</ul>
<p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
<ul>
<li>如果已经建立了连接，但是客户端突然出现故障了怎么办？</li>
</ul>
<p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h4 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h4><p><img src="/posts/5527b4f7/0004.png"></p>
<p><img src="/posts/5527b4f7/0005.png"></p>
<h5 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h5><p>浏览器不会像服务器发送任何请求，直接从本地缓存中读取文件并返回Status Code: 200 OK </p>
<p><img src="/posts/5527b4f7/0006.png"></p>
<p>200 from disk cache： 不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。</p>
<p><img src="/posts/5527b4f7/0007.png"></p>
<p>200 form memory cache : 不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。</p>
<p><strong>header参数</strong></p>
<p>Expires：过期时间，如果设置了时间，则浏览器会在设置的时间内直接读取缓存，不再请求</p>
<p>Cache-Control：当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p>
<p>（1） max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；<br>（2） s-maxage：和max-age是一样的，不过它只针对代理服务器缓存而言；<br>（3）public：指示响应可被任何缓存区缓存；<br>（4）private：只能针对个人用户，而不能被代理服务器缓存；<br>（5）no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到     请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。这个很容易让人产生误解，使人误     以为是响应不被缓存。实际上Cache-Control:     no-cache是会被缓存的，只不过每次在向客户端（浏览器）提供响应数据时，缓存都要向服务器评估缓存响应的有效性。<br>（6）no-store：禁止一切缓存（这个才是响应不被缓存的意思）。</p>
<p>cache-control是http1.1的头字段，expires是http1.0的头字段,如果expires和cache-control同时存在，cache-control会覆盖expires，建议两个都写。</p>
<h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5><p><img src="/posts/5527b4f7/0008.png"></p>
<p>向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；</p>
<p><strong>header参数</strong></p>
<p>Etag/If-None-Match：</p>
<p>Etag是属于HTTP 1.1属性，它是由服务器（Apache或者其他工具）生成返回给前端，用来帮助服务器控制Web端的缓存验证。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。</p>
<p>当资源过期时，浏览器发现响应头里有Etag,则再次像服务器请求时带上请求头if-none-match(值是Etag的值)。服务器收到请求进行比对，决定返回200或304</p>
<p>Last-Modifed/If-Modified-Since：</p>
<p>Last-Modified 浏览器向服务器发送资源最后的修改时间</p>
<p>If-Modified-Since 当资源过期时（浏览器判断Cache-Control标识的max-age过期），发现响应头具有Last-Modified声明，则再次向服务器请求时带上头if-modified-since，表示请求时间。服务器收到请求后发现有if-modified-since则与被请求资源的最后修改时间进行对比（Last-Modified）,若最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK;若最后修改时间较旧（小），说明资源无新修改，响应HTTP 304 走缓存。</p>
<p>Last-Modifed/If-Modified-Since的时间精度是秒，而Etag可以更精确。<br>Etag优先级是高于Last-Modifed的，所以服务器会优先验证Etag<br>Last-Modifed/If-Modified-Since是http1.0的头字段</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B/" rel="tag">应用案例</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" rel="tag">性能优化</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-javascript/engineering/webpack核心概念"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/731d431a/"
    >webpack核心概念</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/731d431a/" class="article-date">
  <time datetime="2020-12-26T14:46:37.000Z" itemprop="datePublished">2020-12-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%B7%A5%E7%A8%8B%E5%8C%96/">工程化</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>推荐就近安装，即安装在项目中，不要安装在全局中</p>
<p>通过 <code>npx webpack -v</code> 查看项目中 webpack 版本</p>
<p><strong>nrm 镜像源管理</strong></p>
<p><code>yarn add nrm</code></p>
<p>查看镜像源列表</p>
<p><code>nrm ls</code></p>
<p>测速</p>
<p><code>nrm test taobao</code></p>
<h4 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h4><h5 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h5><p><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/clean-webpack-plugin">https://www.npmjs.com/package/clean-webpack-plugin</a></p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h4><p>cheap-module-source-map 用于生产环境，不能暴露源码</p>
<p>eval-cheap-module-source-map 开发环境中使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  devtool:<span class="string">&#x27;cheap-module-source-map&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="devServer-和热模块更新"><a href="#devServer-和热模块更新" class="headerlink" title="devServer 和热模块更新"></a>devServer 和热模块更新</h4><p>安装devServer</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add -D webpack-dev-server</span><br></pre></td></tr></table></figure>

<p>webpack.config.js 中添加配置项  </p>
<p>contentBase 只有需要在访问静态文件时候使用，默认下面三个配置项都可以不写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  contentBase: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">  compress: <span class="literal">true</span>,</span><br><span class="line">  port: <span class="number">9000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>package.json 中添加启动命令</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>:&#123;</span><br><span class="line">    <span class="attr">&quot;server&quot;</span>: <span class="string">&quot;webpack-dev-server --open&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启hmr</p>
<p>1.配置webpack-dev-server<br>2.devServer配置hot:true<br>3.plugins hotModuleeReplaceMentPlugin<br>4.js 文件中添加hmr代码</p>
<p>webpack.config.js 中添加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">  ...</span><br><span class="line">  hot:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index.js 增加代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">&#x27;./print.js&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Accepting the updated printMe module!&#x27;</span>);</span><br><span class="line">   printMe();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="output-和-devserver-中的-publicpath-作用"><a href="#output-和-devserver-中的-publicpath-作用" class="headerlink" title="output 和 devserver 中的 publicpath 作用"></a>output 和 devserver 中的 publicpath 作用</h4><p><a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/output/#outputpublicpath">output 中的 publicpath</a></p>
<p>这是一个在使用按需加载和引入外部资源（图片,文件等）非常重要的属性，如果设置了一个错误的值，当加载这些资源时会报404错误</p>
<p>这个配置项指定了输出目录在浏览器中引用时的公共路径（publicpath）,一个相对路径被解析为相对于HTML页面或[‵<base>`标签](<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base</a>)</p>
<blockquote>
<base> 标签为页面上的所有链接规定默认地址或默认目标。
</blockquote>
<p>相对服务器的路径，相对与协议的路径，或绝对路径都是有可能的甚至有时是必须的，换句话说，在CMD 托管静态资源</p>
<p>在运行时或loader处理时，每一个URL的前缀都会被色设置未配置项中的值，这就是为什么在很多例子中这个配置项被设置为 <code>/</code> 的原因</p>
<p>webpack-dev-server 也需要从publicPath获取信息，使用它来确定从何处提供输出文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// One of the below</span></span><br><span class="line">    publicPath: <span class="string">&#x27;https://cdn.example.com/assets/&#x27;</span>, <span class="comment">// CDN (always HTTPS)</span></span><br><span class="line">    publicPath: <span class="string">&#x27;//cdn.example.com/assets/&#x27;</span>, <span class="comment">// CDN (same protocol)</span></span><br><span class="line">    publicPath: <span class="string">&#x27;/assets/&#x27;</span>, <span class="comment">// server-relative</span></span><br><span class="line">    publicPath: <span class="string">&#x27;assets/&#x27;</span>, <span class="comment">// relative to HTML page</span></span><br><span class="line">    publicPath: <span class="string">&#x27;../assets/&#x27;</span>, <span class="comment">// relative to HTML page</span></span><br><span class="line">    publicPath: <span class="string">&#x27;&#x27;</span>, <span class="comment">// relative to HTML page (same directory)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://webpack.js.org/configuration/dev-server/#devserverpublicpath-">devServer 中的 publicpath</a></p>
<p>打包的文件可以在浏览器的这个目录下面得到</p>
<p>如果服务跑在 <a href="http://localhost:8080，打包的文件为bundle.js，publicPath为">http://localhost:8080，打包的文件为bundle.js，publicPath为</a> <code>/</code>, 可以在 <code>http://localhost:8080/bundle.js</code>访问到打包文件</p>
<p>如果 publicPath 改为 <code>/assets/</code>, 那么可以在 <code>http://localhost:8080/assets/bundle.js</code>访问，也可以把 publicPath 改为 <code>http://localhost:8080/assets/</code></p>
<p>这说明了 devServer.publicPath 与 output.publicPath 是一致的</p>
<h5 id="babel-polyfill-babel-plugin-transform-runtime-babel-runtime-corejs2"><a href="#babel-polyfill-babel-plugin-transform-runtime-babel-runtime-corejs2" class="headerlink" title="@babel/polyfill  @babel/plugin-transform-runtime @babel/runtime-corejs2"></a>@babel/polyfill  @babel/plugin-transform-runtime @babel/runtime-corejs2</h5><p>@babel/preset-env 只会转换新语法，但是不会转换新的api,比如 <code>Array.from</code></p>
<p>需要 @babel/polyfill 转换新的api,但是 @babel/polyfill 会全量引入，不能按需引入</p>
<p>可以通过 <code>babel.rc</code> 配置文件来实现</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;useBuiltIns&quot;</span>: <span class="string">&quot;entry&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是@babel/preset-env也存在问题，虽然会按需引入但是每个文件如果有重复的方法，都会被编译成相同的代码引入，文件多的时候会让冗余的代码越来越多</p>
<p>@babel/runtime-corejs2 是一个随着 <a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-plugin-transform-runtime">@babel/plugin-transform-runtime</a> 一起时使用的运行时依赖，会把重复的函数覆盖为 @babel/runtime-corejs2 中的引用</p>
<p>@babel/runtime-corejs2 仅仅是一个包含着函数的包，把函数以模块化的形式引入</p>
<p>.babelrc</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;corejs&quot;</span>: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="treeshaking"><a href="#treeshaking" class="headerlink" title="treeshaking"></a>treeshaking</h4><p>webpack4 production 默认开启，需要引入的库使用commonjs 模块化规范</p>
<p>如 loadsh-es</p>
<h4 id="全局引入"><a href="#全局引入" class="headerlink" title="全局引入"></a>全局引入</h4><p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/provide-plugin/#root">provide-plugin</a></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">    $: <span class="string">&#x27;jquery&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>多入口文件的每一个都会被引入jquery，所以需要提取公共代码</p>
<h4 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h4><p><a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-plugin-syntax-dynamic-import">@babel/plugin-syntax-dynamic-import</a></p>
<p><a target="_blank" rel="noopener" href="https://webpack.js.org/guides/code-splitting/#dynamic-imports">Dynamic Imports</a></p>
<p><strong>需要指明webpackChunkName才能被单独打包</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(</span><br><span class="line">   <span class="comment">/* webpackChunkName: &quot;my-jquery&quot; */</span></span><br><span class="line">   <span class="string">&#x27;jquery&#x27;</span></span><br><span class="line"> )</span><br><span class="line">   .then(<span class="function">(<span class="params">&#123; <span class="keyword">default</span>: $ &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log($)</span><br><span class="line">     <span class="keyword">return</span> $(<span class="string">&#x27;body&#x27;</span>);</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<h4 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h4><p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/split-chunks-plugin/#root">SplitChunksPlugin</a> 代替原来的 commonChunksPlugin</p>
<ul>
<li>splitChunks.chunks</li>
</ul>
<p>async表示只从异步加载得模块（动态加载import()）里面进行拆分<br>initial表示只从入口模块进行拆分<br>all表示以上两者都包括</p>
<ul>
<li>splitChunks.maxInitialRequests</li>
</ul>
<p>每个入口的并发请求数, 如果拆出的包的个数大于maxInitialRequests，则不会把较小的包单独拆出</p>
<ul>
<li>splitChunks.maxInitialRequests</li>
</ul>
<p>动态引入的模块，最多拆分的数量</p>
<h4 id="css分割"><a href="#css分割" class="headerlink" title="css分割"></a>css分割</h4><p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/css-minimizer-webpack-plugin/">css-minimizer-webpack-plugin</a></p>
<h4 id="压缩css代码"><a href="#压缩css代码" class="headerlink" title="压缩css代码"></a>压缩css代码</h4><p><a target="_blank" rel="noopener" href="https://webpack.js.org/plugins/mini-css-extract-plugin/#getting-started">MiniCssExtractPlugin</a></p>
<h4 id="可视化分析"><a href="#可视化分析" class="headerlink" title="可视化分析"></a>可视化分析</h4><p><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/webpack-bundle-analyzer">webpack-bundle-analyzer</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" rel="tag">单元测试</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-javascript/engineering/热部署代码"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/posts/e3b6331f/"
    >热部署代码</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/posts/e3b6331f/" class="article-date">
  <time datetime="2020-12-26T13:26:36.000Z" itemprop="datePublished">2020-12-26</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a> / <a class="article-category-link" href="/categories/JavaScript/%E5%B7%A5%E7%A8%8B%E5%8C%96/">工程化</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> vm = <span class="built_in">require</span>(<span class="string">&quot;vm&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handlerMap = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> hotsPath = path.join(__dirname, <span class="string">&quot;hots&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载文件代码 并 监听指定文件夹目录文件内容变动</span></span><br><span class="line"><span class="keyword">const</span> loadHandlers = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 遍历出指定文件夹下的所有文件</span></span><br><span class="line">  <span class="keyword">const</span> files = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_fs_readdir_path_options_callback</span></span><br><span class="line">    <span class="comment">//异步读取指定目录下的文件和文件夹，返回一个数组</span></span><br><span class="line">    fs.readdir(hotsPath, <span class="function">(<span class="params">err, files</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(files);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 初始化加载所有文件 把每个文件结果缓存到handlerMap变量当中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> f <span class="keyword">in</span> files) &#123;</span><br><span class="line">    handlerMap[files[f]] = <span class="keyword">await</span> loadHandler(path.join(hotsPath, files[f]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听指定文件夹的文件内容变动</span></span><br><span class="line">  <span class="keyword">await</span> watchHandlers();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监视指定文件夹下的文件变动</span></span><br><span class="line"><span class="keyword">const</span> watchHandlers = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 这里建议用chokidar的npm包代替文件夹监听 </span></span><br><span class="line">  <span class="comment">// 监听所有子文件夹</span></span><br><span class="line">  fs.watch(hotsPath, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;, <span class="keyword">async</span> (eventType, filename) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 获取到每个文件的绝对路径 </span></span><br><span class="line">    <span class="comment">// 包一层require.resolve的原因，拼接好路径以后，它会主动去帮你判断这个路径下的文件是否存在</span></span><br><span class="line">    <span class="comment">//使用require.resolve函数查询模块文件名时并不会加载该模块。</span></span><br><span class="line">    <span class="keyword">const</span> targetFile = <span class="built_in">require</span>.resolve(path.join(hotsPath, filename));</span><br><span class="line">    <span class="comment">// 使用require加载一个模块后，模块的数据就会缓存到require.cache中，下次再加载相同模块，就会直接走require.cache</span></span><br><span class="line">    <span class="comment">// 所以我们热加载部署，首要做的就是清除require.cache中对应文件的缓存</span></span><br><span class="line">    <span class="keyword">const</span> cacheModule = <span class="built_in">require</span>.cache[targetFile];</span><br><span class="line">    <span class="comment">// 去除掉在require.cache缓存中parent对当前模块的引用，否则会引起内存泄露，具体解释可以看下面的文章</span></span><br><span class="line">	<span class="comment">// 《记录一次由一行代码引发的“血案”》https://cnodejs.org/topic/5aaba2dc19b2e3db18959e63</span></span><br><span class="line">	<span class="comment">// 《一行 delete require.cache 引发的内存泄漏血案》https://zhuanlan.zhihu.com/p/34702356</span></span><br><span class="line">    <span class="keyword">if</span> (cacheModule.parent) &#123;    </span><br><span class="line">        cacheModule.parent.children.splice(cacheModule.parent.children.indexOf(cacheModule), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除指定路径对应模块的require.cache缓存</span></span><br><span class="line">    <span class="built_in">require</span>.cache[targetFile] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新加载发生变动后的模块文件，实现热加载部署效果，并将重新加载后的结果，更新到handlerMap变量当中</span></span><br><span class="line">    <span class="keyword">const</span> code = <span class="keyword">await</span> loadHandler(targetFile)</span><br><span class="line">    handlerMap[filename] = code;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;热部署文件：&quot;</span>, filename, <span class="string">&quot;，执行结果：&quot;</span>, handlerMap);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载指定文件的代码</span></span><br><span class="line"><span class="keyword">const</span> loadHandler = <span class="function"><span class="params">filename</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//https://nodejs.org/dist/latest-v14.x/docs/api/fs.html#fs_fs_readfile_path_options_callback</span></span><br><span class="line">    <span class="comment">//读取文件中的内容 默认返回buffer</span></span><br><span class="line">    <span class="comment">//当目录为文件夹时抛出错误</span></span><br><span class="line">    fs.readFile(filename, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        resolve(<span class="literal">null</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 使用vm模块的Script方法来预编译发生变化后的文件代码，检查语法错误，提前发现是否存在语法错误等报错</span></span><br><span class="line">          <span class="keyword">new</span> vm.Script(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="comment">// 语法错误,编译失败</span></span><br><span class="line">          reject(e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 编译通过后，重新require加载最新的代码</span></span><br><span class="line">        resolve(<span class="built_in">require</span>(filename));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">loadHandlers()</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/" rel="tag">工程化</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> SunZhiqi
      </li>
    </ul>
    <ul>
      <li>
        
        
        <!--  -->
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <!-- <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a> -->
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/logo.png" alt="四月八日"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>帮到你了么朋友</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/kity.min.js"></script>


<script src="/js/kityminder.core.min.js"></script>


<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->

<!-- CanvasBackground -->


    
  </div>
</body>

</html>